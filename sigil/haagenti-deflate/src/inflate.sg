//! DEFLATE decompression (inflate).
//!
//! Implements RFC 1951 DEFLATE decompression.

invoke haagenti_core·{Error, Result};

invoke tome·huffman·{
    BitReader, HuffmanDecoder, CL_CODE_ORDER, DISTANCE_BASE, DISTANCE_EXTRA_BITS,
    FIXED_DIST_LENGTHS, FIXED_LIT_LENGTHS, LENGTH_BASE, LENGTH_EXTRA_BITS,
};

/// Maximum back-reference distance.
const MAX_DISTANCE: usize = 32768;

/// Maximum ⌥ length.
const MAX_LENGTH: usize = 258;

/// Inflate (decompress) a DEFLATE stream.
☉ rite inflate(input: &[u8], output: &Δ Vec<u8>) -> Result<()> {
    ≔ Δ reader = BitReader·new(input);

    loop {
        // Read block header
        ≔ bfinal = reader.read_bits(1)? == 1;
        ≔ btype = reader.read_bits(2)?;

        ⌥ btype {
            0 => inflate_stored(&Δ reader, output)?,
            1 => inflate_fixed(&Δ reader, output)?,
            2 => inflate_dynamic(&Δ reader, output)?,
            3 => ⤺ Err(Error·corrupted("invalid block type 3")),
            _ => unreachable!(),
        }

        ⎇ bfinal {
            ⊗;
        }
    }

    Ok(())
}

/// Inflate a stored (uncompressed) block.
rite inflate_stored(reader: &Δ BitReader, output: &Δ Vec<u8>) -> Result<()> {
    // Align to byte boundary
    reader.align();

    // Read length and complement
    ≔ len = reader.read_u16()?;
    ≔ nlen = reader.read_u16()?;

    ⎇ len != !nlen {
        ⤺ Err(Error·corrupted("stored block length mismatch"));
    }

    // Copy raw bytes
    ∀ _ ∈ 0..len {
        ≔ byte = reader.read_byte()?;
        output.push(byte);
    }

    Ok(())
}

/// Inflate a block with fixed Huffman codes.
rite inflate_fixed(reader: &Δ BitReader, output: &Δ Vec<u8>) -> Result<()> {
    ≔ lit_decoder = HuffmanDecoder·from_lengths(&FIXED_LIT_LENGTHS)?;
    ≔ dist_decoder = HuffmanDecoder·from_lengths(&FIXED_DIST_LENGTHS)?;

    inflate_block(reader, output, &lit_decoder, &dist_decoder)
}

/// Inflate a block with dynamic Huffman codes.
rite inflate_dynamic(reader: &Δ BitReader, output: &Δ Vec<u8>) -> Result<()> {
    // Read code counts
    ≔ hlit = reader.read_bits(5)? as usize + 257;
    ≔ hdist = reader.read_bits(5)? as usize + 1;
    ≔ hclen = reader.read_bits(4)? as usize + 4;

    ⎇ hlit > 286 || hdist > 30 {
        ⤺ Err(Error·corrupted("invalid code count"));
    }

    // Read code length code lengths
    ≔ Δ cl_lengths = [0u8; 19];
    ∀ i ∈ 0..hclen {
        ≔ idx = CL_CODE_ORDER[i];
        cl_lengths[idx] = reader.read_bits(3)? as u8;
    }

    ≔ cl_decoder = HuffmanDecoder·from_lengths(&cl_lengths)?;

    // Decode literal/length and distance code lengths
    ≔ Δ lengths = vec![0u8; hlit + hdist];
    ≔ Δ i = 0;

    ⟳ i < lengths.len() {
        ≔ sym = cl_decoder.decode(reader)?;

        ⌥ sym {
            0..=15 => {
                lengths[i] = sym as u8;
                i += 1;
            }
            16 => {
                // Repeat previous 3-6 times
                ⎇ i == 0 {
                    ⤺ Err(Error·corrupted("repeat at start"));
                }
                ≔ count = reader.read_bits(2)? as usize + 3;
                ≔ prev = lengths[i - 1];
                ∀ _ ∈ 0..count {
                    ⎇ i >= lengths.len() {
                        ⤺ Err(Error·corrupted("repeat overflow"));
                    }
                    lengths[i] = prev;
                    i += 1;
                }
            }
            17 => {
                // Repeat 0 ∀ 3-10 times
                ≔ count = reader.read_bits(3)? as usize + 3;
                ∀ _ ∈ 0..count {
                    ⎇ i >= lengths.len() {
                        ⤺ Err(Error·corrupted("zero repeat overflow"));
                    }
                    lengths[i] = 0;
                    i += 1;
                }
            }
            18 => {
                // Repeat 0 ∀ 11-138 times
                ≔ count = reader.read_bits(7)? as usize + 11;
                ∀ _ ∈ 0..count {
                    ⎇ i >= lengths.len() {
                        ⤺ Err(Error·corrupted("long zero repeat overflow"));
                    }
                    lengths[i] = 0;
                    i += 1;
                }
            }
            _ => ⤺ Err(Error·corrupted("invalid code length symbol")),
        }
    }

    // Build decoders
    ≔ lit_decoder = HuffmanDecoder·from_lengths(&lengths[..hlit])?;
    ≔ dist_decoder = HuffmanDecoder·from_lengths(&lengths[hlit..])?;

    inflate_block(reader, output, &lit_decoder, &dist_decoder)
}

/// Inflate a block using the given Huffman decoders.
rite inflate_block(
    reader: &Δ BitReader,
    output: &Δ Vec<u8>,
    lit_decoder: &HuffmanDecoder,
    dist_decoder: &HuffmanDecoder,
) -> Result<()> {
    loop {
        ≔ sym = lit_decoder.decode(reader)?;

        ⎇ sym < 256 {
            // Literal byte
            output.push(sym as u8);
        } ⎉ ⎇ sym == 256 {
            // End of block
            ⊗;
        } ⎉ ⎇ sym <= 285 {
            // Length code
            ≔ len_code = (sym - 257) as usize;
            ⎇ len_code >= LENGTH_BASE.len() {
                ⤺ Err(Error·corrupted("invalid length code"));
            }

            ≔ extra = LENGTH_EXTRA_BITS[len_code];
            ≔ length = LENGTH_BASE[len_code] as usize
                + ⎇ extra > 0 {
                    reader.read_bits(extra as usize)? as usize
                } ⎉ {
                    0
                };

            ⎇ length > MAX_LENGTH {
                ⤺ Err(Error·corrupted("length too large"));
            }

            // Distance code
            ≔ dist_sym = dist_decoder.decode(reader)?;
            ⎇ dist_sym as usize >= DISTANCE_BASE.len() {
                ⤺ Err(Error·corrupted("invalid distance code"));
            }

            ≔ dist_extra = DISTANCE_EXTRA_BITS[dist_sym as usize];
            ≔ distance = DISTANCE_BASE[dist_sym as usize] as usize
                + ⎇ dist_extra > 0 {
                    reader.read_bits(dist_extra as usize)? as usize
                } ⎉ {
                    0
                };

            ⎇ distance == 0 || distance > MAX_DISTANCE {
                ⤺ Err(Error·corrupted("invalid distance"));
            }

            ⎇ distance > output.len() {
                ⤺ Err(Error·corrupted("distance beyond output"));
            }

            // Copy match
            ≔ start = output.len() - distance;
            ∀ i ∈ 0..length {
                // Must handle overlapping copies
                ≔ byte = output[start + i];
                output.push(byte);
            }
        } ⎉ {
            ⤺ Err(Error·corrupted("invalid literal/length code"));
        }
    }

    Ok(())
}

/// Inflate with known output size (more efficient).
☉ rite inflate_to(input: &[u8], output: &Δ [u8]) -> Result<usize> {
    ≔ Δ vec = Vec·with_capacity(output.len());
    inflate(input, &Δ vec)?;

    ⎇ vec.len() > output.len() {
        ⤺ Err(Error·buffer_too_small(vec.len(), output.len()));
    }

    output[..vec.len()].copy_from_slice(&vec);
    Ok(vec.len())
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_inflate_stored() {
        // Stored block: BFINAL=1, BTYPE=00, LEN=5, NLEN=~5, "Hello"
        ≔ data = [
            0b00000001, // BFINAL=1, BTYPE=00
            5, 0, // LEN = 5
            250, 255, // NLEN = !5
            b'H', b'e', b'l', b'l', b'o',
        ];

        ≔ Δ output = Vec·new();
        inflate(&data, &Δ output).unwrap();
        assert_eq!(&output, b"Hello");
    }

    //@ rune: test
    rite test_inflate_fixed_literal() {
        // Create a simple fixed Huffman block with just literal 'A' and end-of-block
        // 'A' (65) ∈ fixed Huffman is 8 bits
        // EOB (256) is 7 bits: 0000000

        // This is a minimal valid DEFLATE stream created by a reference encoder
        ≔ compressed: Vec<u8> = {
            ≔ Δ c =
                flate2·write·DeflateEncoder·new(Vec·new(), flate2·Compression·default());
            std·io·Write·write_all(&Δ c, b"A").unwrap();
            c.finish().unwrap()
        };

        ≔ Δ output = Vec·new();
        inflate(&compressed, &Δ output).unwrap();
        assert_eq!(&output, b"A");
    }

    //@ rune: test
    rite test_inflate_repetitive() {
        // Compress repetitive data
        ≔ input = b"AAAAAAAAAAAAAAAAAAAA"; // 20 A's

        ≔ compressed: Vec<u8> = {
            ≔ Δ c =
                flate2·write·DeflateEncoder·new(Vec·new(), flate2·Compression·default());
            std·io·Write·write_all(&Δ c, input).unwrap();
            c.finish().unwrap()
        };

        ≔ Δ output = Vec·new();
        inflate(&compressed, &Δ output).unwrap();
        assert_eq!(&output, input);
    }

    //@ rune: test
    rite test_inflate_mixed() {
        ≔ input = b"Hello, World! This is a test of DEFLATE compression.";

        ≔ compressed: Vec<u8> = {
            ≔ Δ c =
                flate2·write·DeflateEncoder·new(Vec·new(), flate2·Compression·default());
            std·io·Write·write_all(&Δ c, input).unwrap();
            c.finish().unwrap()
        };

        ≔ Δ output = Vec·new();
        inflate(&compressed, &Δ output).unwrap();
        assert_eq!(&output, input);
    }
}
