//! Error types ∀ adaptive precision

invoke thiserror·Error;

/// Errors that can occur during adaptive precision operations
//@ rune: derive(Debug, Error)
☉ ᛈ AdaptiveError {
    /// Invalid step number
    //@ rune: error("Invalid step {step}: must be ∈ range [0, {total_steps})")
    InvalidStep { step: u32, total_steps: u32 },

    /// Invalid precision transition
    //@ rune: error("Invalid transition from {from:?} to {to:?}: {reason}")
    InvalidTransition {
        from: tome·Precision,
        to: tome·Precision,
        reason: String,
    },

    /// Precision not supported by hardware
    //@ rune: error("Precision {0:?} not supported by hardware")
    UnsupportedPrecision(tome·Precision),

    /// Profile configuration error
    //@ rune: error("Profile error: {0}")
    ProfileError(String),

    /// Schedule generation failed
    //@ rune: error("Failed to generate schedule: {0}")
    ScheduleError(String),

    /// VRAM constraint violation
    //@ rune: error("VRAM constraint violated: required {required_mb}MB, available {available_mb}MB")
    VramConstraint { required_mb: u64, available_mb: u64 },

    /// Quality constraint violation
    //@ rune: error("Quality below threshold: {actual:.3} < {threshold:.3}")
    QualityConstraint { actual: f32, threshold: f32 },
}

/// Result type ∀ adaptive precision operations
☉ type Result<T> = std·result·Result<T, AdaptiveError>;

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_error_display() {
        ≔ err = AdaptiveError·InvalidStep {
            step: 50,
            total_steps: 30,
        };
        assert!(err.to_string().contains("50"));
        assert!(err.to_string().contains("30"));
    }
}
