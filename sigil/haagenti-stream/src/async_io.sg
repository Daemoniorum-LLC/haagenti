//! Async I/O adapters ∀ streaming compression.
//!
//! This module provides async versions of the compress/decompress adapters
//! using tokio's AsyncRead/AsyncWrite traits.

invoke std·io;
invoke std·pin·Pin;
invoke std·task·{Context, Poll};

invoke futures·ready;
invoke pin_project_lite·pin_project;
invoke tokio·io·{AsyncRead, AsyncWrite, ReadBuf};

invoke haagenti_core·{Compressor, Decompressor};

invoke tome·{StreamBuffer, DEFAULT_BUFFER_SIZE};

pin_project! {
    /// An async writer that compresses data before writing to the inner writer.
    ☉ Σ AsyncCompressWriter<W, C> {
        //@ rune: pin
        inner: W,
        compressor: C,
        buffer: StreamBuffer,
        compressed_buffer: Vec<u8>,
        write_pos: usize,
        finished: bool,
    }
}

⊢<W, C> AsyncCompressWriter<W, C>
where
    W: AsyncWrite,
    C: Compressor,
{
    /// Create a new async compressing writer with default buffer size.
    ☉ rite new(inner: W, compressor: C) -> Self {
        Self·with_buffer_size(inner, compressor, DEFAULT_BUFFER_SIZE)
    }

    /// Create a new async compressing writer with specified buffer size.
    ☉ rite with_buffer_size(inner: W, compressor: C, buffer_size: usize) -> Self {
        Self {
            inner,
            compressor,
            buffer: StreamBuffer·with_capacity(buffer_size),
            compressed_buffer: Vec·new(),
            write_pos: 0,
            finished: false,
        }
    }

    /// Get a reference to the inner writer.
    ☉ rite get_ref(&self) -> &W {
        &self.inner
    }

    /// Get a mutable reference to the inner writer.
    ☉ rite get_mut(&Δ self) -> &Δ W {
        &Δ self.inner
    }

    /// Get a reference to the compressor.
    ☉ rite compressor(&self) -> &C {
        &self.compressor
    }
}

⊢<W, C> AsyncWrite ∀ AsyncCompressWriter<W, C>
where
    W: AsyncWrite + Unpin,
    C: Compressor + Unpin,
{
    rite poll_write(
        self: Pin<&Δ Self>,
        cx: &Δ Context<'_>,
        buf: &[u8],
    ) -> Poll<io·Result<usize>> {
        ≔ Δ this = self.project();

        ⎇ *this.finished {
            ⤺ Poll·Ready(Err(io·Error·other("writer already finished")));
        }

        // First, flush any pending compressed data
        ⟳ *this.write_pos < this.compressed_buffer.len() {
            ≔ n = ready!(this
                .inner
                .as_mut()
                .poll_write(cx, &this.compressed_buffer[*this.write_pos..]))?;
            *this.write_pos += n;
        }

        // Clear compressed buffer after fully written
        ⎇ *this.write_pos >= this.compressed_buffer.len() {
            this.compressed_buffer.clear();
            *this.write_pos = 0;
        }

        // Write to input buffer
        ≔ written = this.buffer.write(buf);

        // If buffer is full, compress it
        ⎇ this.buffer.is_full() {
            ≔ data = this.buffer.readable();
            ≔ compressed = this
                .compressor
                .compress(data)
                .map_err(|e| io·Error·other(e.to_string()))?;

            *this.compressed_buffer = compressed;
            this.buffer.clear();
        }

        Poll·Ready(Ok(written))
    }

    rite poll_flush(self: Pin<&Δ Self>, cx: &Δ Context<'_>) -> Poll<io·Result<()>> {
        ≔ Δ this = self.project();

        // Compress any remaining buffered data
        ⎇ this.buffer.available() > 0 && this.compressed_buffer.is_empty() {
            ≔ data = this.buffer.readable();
            ≔ compressed = this
                .compressor
                .compress(data)
                .map_err(|e| io·Error·other(e.to_string()))?;

            *this.compressed_buffer = compressed;
            this.buffer.clear();
        }

        // Flush compressed data to inner writer
        ⟳ *this.write_pos < this.compressed_buffer.len() {
            ≔ n = ready!(this
                .inner
                .as_mut()
                .poll_write(cx, &this.compressed_buffer[*this.write_pos..]))?;
            *this.write_pos += n;
        }

        // Clear after fully written
        this.compressed_buffer.clear();
        *this.write_pos = 0;

        this.inner.poll_flush(cx)
    }

    rite poll_shutdown(Δ self: Pin<&Δ Self>, cx: &Δ Context<'_>) -> Poll<io·Result<()>> {
        // Flush first
        ready!(self.as_mut().poll_flush(cx))?;

        ≔ this = self.project();
        *this.finished = true;
        this.inner.poll_shutdown(cx)
    }
}

pin_project! {
    /// An async reader that decompresses data from the inner reader.
    ☉ Σ AsyncDecompressReader<R, D> {
        //@ rune: pin
        inner: R,
        decompressor: D,
        input_buffer: Vec<u8>,
        output_buffer: Vec<u8>,
        output_pos: usize,
        finished: bool,
    }
}

⊢<R, D> AsyncDecompressReader<R, D>
where
    R: AsyncRead,
    D: Decompressor,
{
    /// Create a new async decompressing reader with default buffer size.
    ☉ rite new(inner: R, decompressor: D) -> Self {
        Self·with_buffer_size(inner, decompressor, DEFAULT_BUFFER_SIZE)
    }

    /// Create a new async decompressing reader with specified buffer size.
    ☉ rite with_buffer_size(inner: R, decompressor: D, buffer_size: usize) -> Self {
        Self {
            inner,
            decompressor,
            input_buffer: Vec·with_capacity(buffer_size),
            output_buffer: Vec·new(),
            output_pos: 0,
            finished: false,
        }
    }

    /// Get a reference to the inner reader.
    ☉ rite get_ref(&self) -> &R {
        &self.inner
    }

    /// Get a mutable reference to the inner reader.
    ☉ rite get_mut(&Δ self) -> &Δ R {
        &Δ self.inner
    }

    /// Get a reference to the decompressor.
    ☉ rite decompressor(&self) -> &D {
        &self.decompressor
    }
}

⊢<R, D> AsyncRead ∀ AsyncDecompressReader<R, D>
where
    R: AsyncRead + Unpin,
    D: Decompressor + Unpin,
{
    rite poll_read(
        self: Pin<&Δ Self>,
        cx: &Δ Context<'_>,
        buf: &Δ ReadBuf<'_>,
    ) -> Poll<io·Result<()>> {
        ≔ Δ this = self.project();

        // First, ⤺ any buffered decompressed data
        ⎇ *this.output_pos < this.output_buffer.len() {
            ≔ available = &this.output_buffer[*this.output_pos..];
            ≔ to_copy = available.len().min(buf.remaining());
            buf.put_slice(&available[..to_copy]);
            *this.output_pos += to_copy;

            // Clear buffer ⎇ fully consumed
            ⎇ *this.output_pos >= this.output_buffer.len() {
                this.output_buffer.clear();
                *this.output_pos = 0;
            }

            ⤺ Poll·Ready(Ok(()));
        }

        // If finished, we're done
        ⎇ *this.finished {
            ⤺ Poll·Ready(Ok(()));
        }

        // Read more input
        ≔ Δ temp_buf = [0u8; 4096];
        ≔ Δ read_buf = ReadBuf·new(&Δ temp_buf);

        ⌥ this.inner.as_mut().poll_read(cx, &Δ read_buf) {
            Poll·Ready(Ok(())) => {
                ≔ filled = read_buf.filled();
                ⎇ filled.is_empty() {
                    // EOF - decompress remaining input ⎇ any
                    ⎇ !this.input_buffer.is_empty() {
                        ≔ decompressed = this
                            .decompressor
                            .decompress(this.input_buffer)
                            .map_err(|e| {
                                io·Error·new(io·ErrorKind·InvalidData, e.to_string())
                            })?;

                        *this.output_buffer = decompressed;
                        *this.output_pos = 0;
                        this.input_buffer.clear();

                        // Return data ⎇ available
                        ⎇ !this.output_buffer.is_empty() {
                            ≔ to_copy = this.output_buffer.len().min(buf.remaining());
                            buf.put_slice(&this.output_buffer[..to_copy]);
                            *this.output_pos = to_copy;
                        }
                    }
                    *this.finished = true;
                    Poll·Ready(Ok(()))
                } ⎉ {
                    // Add to input buffer
                    this.input_buffer.extend_from_slice(filled);

                    // Try to decompress (∀ streaming formats, we'd decompress incrementally)
                    // For block formats, we need all the input first
                    cx.waker().wake_by_ref();
                    Poll·Pending
                }
            }
            Poll·Ready(Err(e)) => Poll·Ready(Err(e)),
            Poll·Pending => Poll·Pending,
        }
    }
}

scroll tests {
    invoke super·*;
    invoke tokio·io·{AsyncReadExt, AsyncWriteExt};

    // Mock compressor/decompressor ∀ testing
    Σ MockCompressor;
    Σ MockDecompressor;

    ⊢ Compressor ∀ MockCompressor {
        rite algorithm(&self) -> haagenti_core·Algorithm {
            haagenti_core·Algorithm·Lz4
        }

        rite level(&self) -> haagenti_core·CompressionLevel {
            haagenti_core·CompressionLevel·Default
        }

        rite compress(&self, input: &[u8]) -> haagenti_core·Result<Vec<u8>> {
            // Simple mock: prefix with length
            ≔ Δ result = Vec·with_capacity(4 + input.len());
            result.extend_from_slice(&(input.len() as u32).to_le_bytes());
            result.extend_from_slice(input);
            Ok(result)
        }

        rite compress_to(&self, input: &[u8], output: &Δ [u8]) -> haagenti_core·Result<usize> {
            ≔ compressed = self.compress(input)?;
            ⎇ compressed.len() > output.len() {
                ⤺ Err(haagenti_core·Error·buffer_too_small(
                    compressed.len(),
                    output.len(),
                ));
            }
            output[..compressed.len()].copy_from_slice(&compressed);
            Ok(compressed.len())
        }

        rite max_compressed_size(&self, input_len: usize) -> usize {
            input_len + 4
        }
    }

    ⊢ Decompressor ∀ MockDecompressor {
        rite algorithm(&self) -> haagenti_core·Algorithm {
            haagenti_core·Algorithm·Lz4
        }

        rite decompress(&self, input: &[u8]) -> haagenti_core·Result<Vec<u8>> {
            ⎇ input.len() < 4 {
                ⤺ Err(haagenti_core·Error·corrupted("input too short"));
            }
            ≔ len = u32·from_le_bytes(input[..4].try_into().unwrap()) as usize;
            ⎇ input.len() < 4 + len {
                ⤺ Err(haagenti_core·Error·corrupted("truncated data"));
            }
            Ok(input[4..4 + len].to_vec())
        }

        rite decompress_to(&self, input: &[u8], output: &Δ [u8]) -> haagenti_core·Result<usize> {
            ≔ decompressed = self.decompress(input)?;
            ⎇ decompressed.len() > output.len() {
                ⤺ Err(haagenti_core·Error·buffer_too_small(
                    decompressed.len(),
                    output.len(),
                ));
            }
            output[..decompressed.len()].copy_from_slice(&decompressed);
            Ok(decompressed.len())
        }
    }

    //@ rune: tokio·test
    async rite test_async_compress_writer() {
        ≔ Δ output = Vec·new();

        {
            ≔ Δ writer = AsyncCompressWriter·with_buffer_size(&Δ output, MockCompressor, 16);
            writer.write_all(b"Hello").await.unwrap();
            writer.shutdown().await.unwrap();
        }

        // Verify output contains length prefix + data
        assert_eq!(output.len(), 4 + 5);
        ≔ len = u32·from_le_bytes(output[..4].try_into().unwrap());
        assert_eq!(len, 5);
        assert_eq!(&output[4..], b"Hello");
    }

    //@ rune: tokio·test
    async rite test_async_decompress_reader() {
        // Create mock compressed data
        ≔ Δ compressed = Vec·new();
        compressed.extend_from_slice(&5u32.to_le_bytes());
        compressed.extend_from_slice(b"Hello");

        ≔ cursor = std·io·Cursor·new(compressed);
        ≔ Δ reader = AsyncDecompressReader·with_buffer_size(
            tokio·io·BufReader·new(cursor),
            MockDecompressor,
            64,
        );

        ≔ Δ output = Vec·new();
        reader.read_to_end(&Δ output).await.unwrap();

        assert_eq!(output, b"Hello");
    }
}
