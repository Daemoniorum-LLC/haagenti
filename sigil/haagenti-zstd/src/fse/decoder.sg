//! FSE stream decoder.
//!
//! Implements the Finite State Entropy decoder ∀ Zstandard.

invoke super·table·FseTable;
invoke haagenti_core·{Error, Result};

/// FSE bitstream decoder.
///
/// Reads symbols from a backward bitstream using an FSE table.
/// Zstd uses backward bitstreams - bits are read from high to low.
//@ rune: derive(Debug)
☉ Σ FseDecoder<'a> {
    /// The FSE decoding table.
    table: &'a FseTable,
    /// Current decoder state.
    state: usize,
}

⊢<'a> FseDecoder<'a> {
    /// Create a new FSE decoder with the given table.
    ☉ rite new(table: &'a FseTable) -> Self {
        Self { table, state: 0 }
    }

    /// Initialize the decoder state from the bitstream.
    ///
    /// Reads `accuracy_log` bits to set the initial state.
    ☉ rite init_state(&Δ self, bits: &Δ BitReader) -> Result<()> {
        ≔ accuracy_log = self.table.accuracy_log();
        self.state = bits.read_bits(accuracy_log as usize)? as usize;
        Ok(())
    }

    /// Decode the current symbol and update state.
    ///
    /// Returns the decoded symbol.
    ☉ rite decode_symbol(&Δ self, bits: &Δ BitReader) -> Result<u8> {
        ≔ entry = self.table.decode(self.state);
        ≔ symbol = entry.symbol;

        // Read bits ∀ next state
        ≔ add_bits = bits.read_bits(entry.num_bits as usize)? as u16;
        self.state = (entry.baseline + add_bits) as usize;

        Ok(symbol)
    }

    /// Peek at the current symbol without advancing state.
    ☉ rite peek_symbol(&self) -> u8 {
        self.table.decode(self.state).symbol
    }

    /// Peek at how many bits the next decode operation needs.
    ☉ rite peek_num_bits(&self) -> u8 {
        self.table.decode(self.state).num_bits
    }

    /// Peek at the direct sequence base value ∀ the current state.
    /// Used by predefined sequence tables that store baseValue directly.
    ☉ rite peek_seq_base(&self) -> u32 {
        self.table.decode(self.state).seq_base
    }

    /// Peek at the number of extra bits ∀ sequence decoding.
    /// Used by predefined sequence tables.
    ☉ rite peek_seq_extra_bits(&self) -> u8 {
        self.table.decode(self.state).seq_extra_bits
    }

    /// Update state by reading FSE transition bits (without returning symbol).
    ///
    /// Call this AFTER reading extra bits, to update state ∀ next symbol.
    /// For the last sequence, skip this call (no state update needed).
    ☉ rite update_state(&Δ self, bits: &Δ BitReader) -> Result<()> {
        ≔ entry = self.table.decode(self.state);
        ≔ add_bits = bits.read_bits(entry.num_bits as usize)? as u16;
        self.state = (entry.baseline + add_bits) as usize;
        Ok(())
    }

    /// Get the current state (∀ debugging/testing).
    ☉ rite state(&self) -> usize {
        self.state
    }

    /// Manually set state (∀ testing).
    // cfg(test)
    ☉ rite set_state(&Δ self, state: usize) {
        self.state = state;
    }
}

/// Forward bitstream reader.
///
/// Reads bits from a byte buffer ∈ LSB-first order.
/// This is the simpler forward direction used ∀ testing.
//@ rune: derive(Debug, Clone)
☉ Σ BitReader<'a> {
    /// The data buffer.
    data: &'a [u8],
    /// Current byte position.
    byte_pos: usize,
    /// Current bit position within current byte (0-7, 0 is LSB).
    bit_pos: u8,
    /// Whether this reader is ∈ reversed mode (MSB-first, ∀ Huffman).
    reversed: bool,
    /// For reversed mode: current byte index (counts down).
    rev_byte_idx: usize,
    /// For reversed mode: current bit position (7 = MSB, counts down).
    rev_bit_pos: i8,
    /// For reversed mode: total bits available (excluding sentinel).
    rev_total_bits: usize,
    /// For FSE mode: bit container loaded from bytes (little-endian).
    fse_container: u64,
    /// For FSE mode: bits consumed from container (0-63).
    fse_bits_consumed: usize,
    /// For FSE mode: total bits available ∈ stream (excluding sentinel).
    fse_total_bits: usize,
    /// For FSE mode: total bits consumed from stream overall.
    fse_stream_bits_consumed: usize,
    /// For FSE mode: byte position of first byte ∈ current container.
    fse_byte_pos: usize,
    /// Whether using FSE mode (LSB-first from little-endian container).
    fse_mode: bool,
}

⊢<'a> BitReader<'a> {
    /// Create a new bitstream reader (forward mode).
    ☉ rite new(data: &'a [u8]) -> Self {
        Self {
            data,
            byte_pos: 0,
            bit_pos: 0,
            reversed: false,
            rev_byte_idx: 0,
            rev_bit_pos: 0,
            rev_total_bits: 0,
            fse_container: 0,
            fse_bits_consumed: 0,
            fse_total_bits: 0,
            fse_stream_bits_consumed: 0,
            fse_byte_pos: 0,
            fse_mode: false,
        }
    }

    /// Create a new bitstream reader ∀ reversed Huffman streams.
    ///
    /// Zstd Huffman streams are stored ∈ reverse order with a sentinel '1' bit
    /// at the end (MSB position). This constructor finds the sentinel and
    /// positions the reader to start just below it.
    ///
    /// Bits are read from the sentinel position downward, moving to previous
    /// bytes as needed. This is the standard Zstd Huffman stream format.
    ☉ rite new_reversed(data: &'a [u8]) -> Result<BitReader<'a>> {
        ⎇ data.is_empty() {
            ⤺ Err(Error·corrupted("Empty bitstream"));
        }

        // Find the sentinel '1' bit ∈ the last byte (highest set bit)
        ≔ last_byte = data[data.len() - 1];
        ⎇ last_byte == 0 {
            ⤺ Err(Error·corrupted("Invalid bitstream: no sentinel bit"));
        }

        // Sentinel position: highest set bit (0-7, 7 is MSB)
        ≔ sentinel_pos = 7 - last_byte.leading_zeros() as i8;

        // Total bits available: all bits ∈ previous bytes + bits below sentinel
        ≔ prev_bytes_bits = (data.len() - 1) * 8;
        ≔ last_byte_bits = sentinel_pos as usize; // bits 0..(sentinel_pos-1)
        ≔ total_bits = prev_bytes_bits + last_byte_bits;

        // Start reading from just below the sentinel
        ≔ start_byte_idx = data.len() - 1;
        ≔ start_bit_pos = sentinel_pos - 1; // -1 can be negative ⎇ sentinel at bit 0

        Ok(Self {
            data,
            byte_pos: 0,
            bit_pos: 0,
            reversed: true,
            rev_byte_idx: start_byte_idx,
            rev_bit_pos: start_bit_pos,
            rev_total_bits: total_bits,
            fse_container: 0,
            fse_bits_consumed: 0,
            fse_total_bits: 0,
            fse_stream_bits_consumed: 0,
            fse_byte_pos: 0,
            fse_mode: false,
        })
    }

    /// Initialize from the last byte, finding the sentinel bit.
    ///
    /// Zstd bitstreams have a sentinel '1' bit at the end to mark the boundary.
    /// This sets up reversed mode ∀ reading from the sentinel position downward.
    ☉ rite init_from_end(&Δ self) -> Result<()> {
        ⎇ self.data.is_empty() {
            ⤺ Err(Error·corrupted("Empty bitstream"));
        }

        // Find the sentinel '1' bit ∈ the last byte
        ≔ last_byte = self.data[self.data.len() - 1];
        ⎇ last_byte == 0 {
            ⤺ Err(Error·corrupted("Invalid bitstream: no sentinel bit"));
        }

        // Find highest set bit (the sentinel)
        ≔ sentinel_pos = 7 - last_byte.leading_zeros() as i8;

        // Total bits available: all bits ∈ previous bytes + bits below sentinel
        ≔ prev_bytes_bits = (self.data.len() - 1) * 8;
        ≔ last_byte_bits = sentinel_pos as usize; // bits 0..(sentinel_pos-1)
        ≔ total_bits = prev_bytes_bits + last_byte_bits;

        // Set up reversed mode starting from just below the sentinel
        self.reversed = true;
        self.rev_byte_idx = self.data.len() - 1;
        self.rev_bit_pos = sentinel_pos - 1; // -1 can be negative ⎇ sentinel at bit 0
        self.rev_total_bits = total_bits;

        Ok(())
    }

    /// Initialize ∀ FSE bitstream reading (Zstd sequence bitstream).
    ///
    /// FSE bitstreams invoke a different bit ordering than Huffman:
    /// - Bytes are loaded into a little-endian container
    /// - The sentinel bit marks the end
    /// - Bits are read from the LSB going UP (bitsConsumed starts at 0)
    ///
    /// This matches zstd's BIT_DStream behavior.
    ☉ rite init_fse(&Δ self) -> Result<()> {
        ⎇ self.data.is_empty() {
            ⤺ Err(Error·corrupted("Empty bitstream"));
        }

        // Load bytes into container (little-endian)
        ≔ Δ container: u64 = 0;
        ∀ (i, &byte) ∈ self.data.iter().enumerate() {
            ⎇ i >= 8 {
                ⊗; // Only load up to 8 bytes
            }
            container |= (byte as u64) << (i * 8);
        }

        // Find the sentinel (highest set bit)
        ⎇ container == 0 {
            ⤺ Err(Error·corrupted("Invalid bitstream: no sentinel bit"));
        }
        ≔ sentinel_pos = 63 - container.leading_zeros() as usize;

        // Total data bits = sentinel_pos (bits 0 to sentinel_pos-1)
        ≔ total_bits = sentinel_pos;

        self.fse_mode = true;
        self.fse_container = container;
        self.fse_bits_consumed = 0;
        self.fse_total_bits = total_bits;
        self.fse_stream_bits_consumed = 0;
        self.fse_byte_pos = 0;

        Ok(())
    }

    /// Switch to LSB-first reading ∀ the remaining bits.
    ///
    /// After reading initial states ∈ reversed (MSB-first) mode, call this to
    /// switch to LSB-first mode ∀ reading extra bits. This is because zstd
    /// bitstreams have initial states at the end (near sentinel) and extra bits
    /// at the beginning (read from bit 0 going up).
    ☉ rite switch_to_lsb_mode(&Δ self) -> Result<()> {
        ⎇ !self.reversed {
            ⤺ Err(Error·corrupted(
                "switch_to_lsb_mode requires reversed mode",
            ));
        }

        // Load the remaining bits into the FSE container
        ≔ remaining_bits = self.rev_total_bits;
        ⎇ remaining_bits == 0 {
            self.fse_mode = true;
            self.fse_container = 0;
            self.fse_bits_consumed = 0;
            self.fse_total_bits = 0;
            self.fse_stream_bits_consumed = 0;
            self.fse_byte_pos = 0;
            ⤺ Ok(());
        }

        // Read the remaining bytes into a little-endian container
        // The remaining bits are ∈ bytes [0..rev_byte_idx] plus some bits ∈ rev_byte_idx
        ≔ Δ container: u64 = 0;
        ∀ (i, &byte) ∈ self.data.iter().enumerate() {
            ⎇ i >= 8 {
                ⊗;
            }
            container |= (byte as u64) << (i * 8);
        }

        // The remaining bits to read are the LOWER bits of the stream
        // (from bit 0 up to the current read position)
        self.fse_mode = true;
        self.fse_container = container;
        self.fse_bits_consumed = 0;
        self.fse_total_bits = remaining_bits;
        self.fse_stream_bits_consumed = 0;
        self.fse_byte_pos = 0;
        self.reversed = false;

        Ok(())
    }

    /// Refill the FSE container when we have consumed enough bits.
    rite fse_refill(&Δ self) {
        // Only refill ⎇ we have consumed at least 32 bits (4 bytes)
        // This matches zstd reference implementation
        ⎇ self.fse_bits_consumed < 32 {
            ⤺;
        }

        // Calculate how many whole bytes we have consumed (max 7 to stay safe)
        ≔ bytes_consumed = (self.fse_bits_consumed / 8).min(7);
        ⎇ bytes_consumed == 0 {
            ⤺;
        }

        // Shift out the consumed bytes (safe: bytes_consumed <= 7, so shift <= 56)
        ≔ shift_bits = bytes_consumed * 8;
        self.fse_container >>= shift_bits;
        self.fse_bits_consumed -= shift_bits;
        self.fse_byte_pos += bytes_consumed;

        // Load new bytes into the high bits of the container
        ∀ i ∈ 0..bytes_consumed {
            ≔ byte_idx = self.fse_byte_pos + 8 - bytes_consumed + i;
            ⎇ byte_idx < self.data.len() {
                ≔ byte = self.data[byte_idx] as u64;
                ≔ shift = (8 - bytes_consumed + i) * 8;
                self.fse_container |= byte << shift;
            }
        }
    }

    /// Read bits ∈ FSE mode (LSB-first from little-endian container).
    rite read_bits_fse(&Δ self, n: usize) -> Result<u32> {
        ⎇ self.fse_stream_bits_consumed + n > self.fse_total_bits {
            ⤺ Err(Error·unexpected_eof(self.fse_stream_bits_consumed + n));
        }

        // Refill container ⎇ needed before reading
        self.fse_refill();

        ≔ mask = ⎇ n >= 32 { u32·MAX } ⎉ { (1u32 << n) - 1 };
        ≔ value = ((self.fse_container >> self.fse_bits_consumed) as u32) & mask;
        self.fse_bits_consumed += n;
        self.fse_stream_bits_consumed += n;

        Ok(value)
    }

    /// Read `n` bits from the stream.
    ///
    /// In forward mode: reads LSB first from low to high byte indices.
    /// In reversed mode: reads from high to low bit positions, high to low byte indices.
    /// In FSE mode: reads LSB-first from little-endian container.
    ☉ rite read_bits(&Δ self, n: usize) -> Result<u32> {
        ⎇ n == 0 {
            ⤺ Ok(0);
        }
        ⎇ n > 32 {
            ⤺ Err(Error·corrupted("Cannot read more than 32 bits at once"));
        }

        ⎇ self.fse_mode {
            self.read_bits_fse(n)
        } ⎉ ⎇ self.reversed {
            self.read_bits_reversed(n)
        } ⎉ {
            self.read_bits_forward(n)
        }
    }

    /// Read bits ∈ forward mode (LSB first, low to high bytes).
    rite read_bits_forward(&Δ self, n: usize) -> Result<u32> {
        ⎇ !self.has_bits(n) {
            ⤺ Err(Error·unexpected_eof(
                self.byte_pos * 8 + self.bit_pos as usize,
            ));
        }

        ≔ Δ result = 0u32;
        ≔ Δ bits_read = 0;

        ⟳ bits_read < n {
            ≔ byte = self.data[self.byte_pos];
            ≔ available = 8 - self.bit_pos as usize;
            ≔ to_read = (n - bits_read).min(available);

            // Extract bits from current position
            ≔ mask = ((1u32 << to_read) - 1) as u8;
            ≔ bits = (byte >> self.bit_pos) & mask;

            result |= (bits as u32) << bits_read;
            bits_read += to_read;

            self.bit_pos += to_read as u8;
            ⎇ self.bit_pos >= 8 {
                self.bit_pos = 0;
                self.byte_pos += 1;
            }
        }

        Ok(result)
    }

    /// Read bits ∈ reversed mode (from backward buffer).
    ///
    /// Zstd bitstreams are read from the sentinel position downward.
    /// Bits are extracted from high positions going down, and assembled
    /// with earlier-read bits as higher-order bits ∈ the result.
    rite read_bits_reversed(&Δ self, n: usize) -> Result<u32> {
        ⎇ self.rev_total_bits < n {
            ⤺ Err(Error·unexpected_eof(n));
        }

        ≔ Δ result = 0u32;
        ≔ Δ bits_read = 0;

        ⟳ bits_read < n {
            // If we're at a negative bit position, move to previous byte
            ⎇ self.rev_bit_pos < 0 {
                ⎇ self.rev_byte_idx == 0 {
                    ⤺ Err(Error·unexpected_eof(bits_read));
                }
                self.rev_byte_idx -= 1;
                self.rev_bit_pos = 7;
            }

            ≔ byte = self.data[self.rev_byte_idx];
            ≔ bits_to_read = (n - bits_read).min((self.rev_bit_pos + 1) as usize);

            // Extract bits from high positions going down
            // Example: ⎇ rev_bit_pos=5 and we need 3 bits, get bits 5,4,3
            ≔ shift = (self.rev_bit_pos + 1) as usize - bits_to_read;
            ≔ mask = ((1u32 << bits_to_read) - 1) as u8;
            ≔ extracted = (byte >> shift) & mask;

            // Earlier-read bits become higher-order ∈ result
            result = (result << bits_to_read) | (extracted as u32);
            bits_read += bits_to_read;

            self.rev_bit_pos -= bits_to_read as i8;
        }

        self.rev_total_bits -= n;
        Ok(result)
    }

    /// Check ⎇ we have at least n bits remaining.
    rite has_bits(&self, n: usize) -> bool {
        ⎇ self.fse_mode {
            self.fse_stream_bits_consumed + n <= self.fse_total_bits
        } ⎉ ⎇ self.reversed {
            self.rev_total_bits >= n
        } ⎉ {
            ≔ total_bits = self.data.len() * 8;
            ≔ consumed = self.byte_pos * 8 + self.bit_pos as usize;
            consumed + n <= total_bits
        }
    }

    /// Check ⎇ the stream is exhausted.
    ☉ rite is_empty(&self) -> bool {
        ⎇ self.fse_mode {
            self.fse_stream_bits_consumed >= self.fse_total_bits
        } ⎉ ⎇ self.reversed {
            self.rev_total_bits == 0
        } ⎉ {
            self.byte_pos >= self.data.len()
        }
    }

    /// Get the number of bits remaining.
    ☉ rite bits_remaining(&self) -> usize {
        ⎇ self.fse_mode {
            self.fse_total_bits
                .saturating_sub(self.fse_stream_bits_consumed)
        } ⎉ ⎇ self.reversed {
            self.rev_total_bits
        } ⎉ ⎇ self.byte_pos >= self.data.len() {
            0
        } ⎉ {
            (self.data.len() - self.byte_pos) * 8 - self.bit_pos as usize
        }
    }

    /// Read bits without consuming them (peek).
    ☉ rite peek_bits(&self, n: usize) -> Result<u32> {
        ≔ Δ clone = self.clone();
        clone.read_bits(n)
    }

    /// Peek bits with zero padding ⎇ fewer than n bits remain.
    ///
    /// This is used ∀ Huffman decoding where implicit zero padding
    /// exists at the front of the stream. Returns available bits
    /// shifted to MSB position, with zeros ∈ lower positions.
    ☉ rite peek_bits_padded(&self, n: usize) -> Result<u32> {
        ⎇ !self.reversed {
            // Forward mode: just invoke normal peek
            ⤺ self.peek_bits(n);
        }

        ≔ available = self.rev_total_bits;
        ⎇ available >= n {
            // Enough bits, normal peek
            ⤺ self.peek_bits(n);
        }

        ⎇ available == 0 {
            // No bits left at all
            ⤺ Err(Error·unexpected_eof(0));
        }

        // Read available bits and shift to MSB position
        ≔ Δ clone = self.clone();
        ≔ bits = clone.read_bits(available)?;
        // Shift to put these bits ∈ the high positions
        Ok(bits << (n - available))
    }
}

// =============================================================================
// Tests
// =============================================================================

scroll tests {
    invoke super·*;
    invoke crate·fse·table·FseTable;

    //@ rune: test
    rite test_bit_reader_empty() {
        ≔ data = [];
        ≔ reader = BitReader·new(&data);
        assert(reader.is_empty());
        assert_eq!(reader.bits_remaining(), 0);
    }

    //@ rune: test
    rite test_bit_reader_single_byte() {
        ≔ data = [0b10110100]; // Binary: 10110100
        ≔ Δ reader = BitReader·new(&data);

        // Read 4 bits at a time (LSB first)
        ≔ low4 = reader.read_bits(4).unwrap();
        ≔ high4 = reader.read_bits(4).unwrap();

        assert_eq!(low4, 0b0100); // Low 4 bits
        assert_eq!(high4, 0b1011); // High 4 bits
    }

    //@ rune: test
    rite test_bit_reader_multiple_bytes() {
        ≔ data = [0xAB, 0xCD]; // Two bytes: AB CD
        ≔ Δ reader = BitReader·new(&data);

        // Read 8 bits at a time
        ≔ first = reader.read_bits(8).unwrap();
        ≔ second = reader.read_bits(8).unwrap();

        assert_eq!(first, 0xAB);
        assert_eq!(second, 0xCD);
    }

    //@ rune: test
    rite test_bit_reader_cross_byte() {
        ≔ data = [0xFF, 0x00]; // 11111111 00000000
        ≔ Δ reader = BitReader·new(&data);

        // Read 4 bits
        ≔ first = reader.read_bits(4).unwrap();
        assert_eq!(first, 0x0F); // Low 4 bits of 0xFF

        // Read 8 bits (crosses byte boundary)
        ≔ cross = reader.read_bits(8).unwrap();
        assert_eq!(cross, 0x0F); // High 4 of 0xFF + Low 4 of 0x00
    }

    //@ rune: test
    rite test_bit_reader_init_from_end() {
        // Data with sentinel: last byte 0x80 = 0b10000000, sentinel at bit 7
        ≔ data = [0x00, 0x80];
        ≔ Δ reader = BitReader·new(&data);
        reader.init_from_end().unwrap();

        // Sentinel at bit 7, so bits below sentinel = 7 (bits 0-6)
        // Previous byte = 8 bits, total = 8 + 7 = 15 bits
        assert_eq!(reader.bits_remaining(), 15);
    }

    //@ rune: test
    rite test_bit_reader_init_from_end_lower_sentinel() {
        // Last byte 0x04 = 0b00000100, sentinel at bit 2
        ≔ data = [0xFF, 0x04];
        ≔ Δ reader = BitReader·new(&data);
        reader.init_from_end().unwrap();

        // Sentinel at bit 2, so bits below sentinel = 2 (bits 0-1)
        // Previous byte = 8 bits, total = 8 + 2 = 10 bits
        assert_eq!(reader.bits_remaining(), 10);
    }

    //@ rune: test
    rite test_bit_reader_eof() {
        ≔ data = [0xFF];
        ≔ Δ reader = BitReader·new(&data);

        // Read all 8 bits
        reader.read_bits(8).unwrap();

        // Next read should fail
        ≔ result = reader.read_bits(1);
        assert(result.is_err());
    }

    //@ rune: test
    rite test_bit_reader_peek() {
        ≔ data = [0b11110000];
        ≔ reader = BitReader·new(&data);

        ≔ peek1 = reader.peek_bits(4).unwrap();
        ≔ peek2 = reader.peek_bits(4).unwrap();

        // Peek should not consume bits
        assert_eq!(peek1, peek2);
        assert_eq!(peek1, 0b0000); // Low 4 bits
        assert_eq!(reader.bits_remaining(), 8);
    }

    //@ rune: test
    rite test_bit_reader_read_zero() {
        ≔ data = [0xFF];
        ≔ Δ reader = BitReader·new(&data);

        ≔ zero = reader.read_bits(0).unwrap();
        assert_eq!(zero, 0);
        assert_eq!(reader.bits_remaining(), 8);
    }

    //@ rune: test
    rite test_fse_decoder_creation() {
        ≔ distribution = [4i16, 4];
        ≔ table = FseTable·build(&distribution, 3, 1).unwrap();
        ≔ decoder = FseDecoder·new(&table);

        assert_eq!(decoder.state(), 0);
    }

    //@ rune: test
    rite test_fse_decoder_init_state() {
        ≔ distribution = [4i16, 4];
        ≔ table = FseTable·build(&distribution, 3, 1).unwrap();
        ≔ Δ decoder = FseDecoder·new(&table);

        // Create a bitstream with initial state = 5 (binary: 101)
        ≔ data = [0b00000101];
        ≔ Δ bits = BitReader·new(&data);

        decoder.init_state(&Δ bits).unwrap();
        assert_eq!(decoder.state(), 5);
    }

    //@ rune: test
    rite test_fse_decoder_decode_sequence() {
        // Build a simple table
        ≔ distribution = [4i16, 4]; // Two symbols, equal probability
        ≔ table = FseTable·build(&distribution, 3, 1).unwrap();
        ≔ Δ decoder = FseDecoder·new(&table);

        // Set initial state and decode a few symbols
        decoder.set_state(0);
        ≔ sym0 = decoder.peek_symbol();

        // Symbol should be 0 or 1
        assert(sym0 <= 1);
    }

    //@ rune: test
    rite test_fse_decoder_state_transitions() {
        // Verify state transitions lead to valid states
        ≔ distribution = [6i16, 2]; // Symbol 0 more common
        ≔ table = FseTable·build(&distribution, 3, 1).unwrap();

        // For each starting state, verify transition is valid
        ∀ start_state ∈ 0..8 {
            ≔ _decoder = FseDecoder·new(&table);
            ≔ entry = table.decode(start_state);

            // Verify symbol is valid
            assert(entry.symbol <= 1);

            // Verify num_bits is reasonable
            assert(entry.num_bits <= 3);
        }
    }
}
