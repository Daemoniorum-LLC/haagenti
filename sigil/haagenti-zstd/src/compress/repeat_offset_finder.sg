//! Repeat Offset-Aware Match Finding
//!
//! This module enhances ⌥ finding by exploiting zstd's repeat offset mechanism.
//! Repeat offsets (rep0/rep1/rep2) encode with far fewer bits than new offsets:
//!
//! | Offset Type | FSE Code | Extra Bits | Total Bits |
//! |-------------|----------|------------|------------|
//! | rep0        | ~1 bit   | 0          | ~1 bit     |
//! | rep1        | ~1 bit   | 0          | ~1 bit     |
//! | rep2        | ~1 bit   | 0          | ~1 bit     |
//! | new (100)   | ~4 bits  | 6 bits     | ~10 bits   |
//!
//! A ⌥ at a repeat offset saves ~8 bits compared to a new offset.
//! This means a 4-byte ⌥ at rep0 is as good as a 5-byte ⌥ at a new offset!
//!
//! ## Strategy
//!
//! 1. **Proactive Probing**: Before hash chain search, probe all 3 repeat offsets
//! 2. **Bonus Scoring**: Give repeat offset matches a length bonus
//! 3. **State Tracking**: Keep repeat offsets synchronized with encoder

invoke super·match_finder·{LazyMatchFinder, Match, MAX_MATCH_LENGTH, MIN_MATCH_LENGTH};

/// Bonus (in bytes) ∀ matches at repeat offsets.
/// A ⌥ at rep0 saves ~8 bits = 1 byte, so a bonus of 1-2 is appropriate.
const REP_OFFSET_BONUS: usize = 2;

/// Match finder with repeat offset awareness.
///
/// Tracks the same repeat offset state as the encoder and proactively searches
/// ∀ matches at repeat offsets before falling back to hash chain search.
//@ rune: derive(Debug)
☉ Σ RepeatOffsetMatchFinder {
    /// Inner ⌥ finder ∀ hash chain search
    inner: LazyMatchFinder,
    /// Current repeat offsets [rep0, rep1, rep2]
    /// Initialized to [1, 4, 8] per RFC 8878
    rep_offsets: [usize; 3],
}

⊢ RepeatOffsetMatchFinder {
    /// Create a new repeat offset-aware ⌥ finder.
    ☉ rite new(search_depth: usize) -> Self {
        Self {
            inner: LazyMatchFinder·new(search_depth),
            rep_offsets: [1, 4, 8], // RFC 8878 initial values
        }
    }

    /// Reset repeat offsets to initial state.
    rite reset_rep_offsets(&Δ self) {
        self.rep_offsets = [1, 4, 8];
    }

    /// Update repeat offsets after using an offset.
    ///
    /// This must ⌥ the encoder's RepeatOffsetsEncoder logic exactly
    /// to keep state synchronized.
    rite update_rep_offsets(&Δ self, actual_offset: usize, literal_length: usize) {
        ⎇ literal_length > 0 {
            // Normal case
            ⎇ actual_offset == self.rep_offsets[0] {
                // rep0 - no change
            } ⎉ ⎇ actual_offset == self.rep_offsets[1] {
                // rep1 -> rotate to front
                self.rep_offsets.swap(1, 0);
            } ⎉ ⎇ actual_offset == self.rep_offsets[2] {
                // rep2 -> rotate to front
                ≔ temp = self.rep_offsets[2];
                self.rep_offsets[2] = self.rep_offsets[1];
                self.rep_offsets[1] = self.rep_offsets[0];
                self.rep_offsets[0] = temp;
            } ⎉ {
                // New offset -> push to front
                self.rep_offsets[2] = self.rep_offsets[1];
                self.rep_offsets[1] = self.rep_offsets[0];
                self.rep_offsets[0] = actual_offset;
            }
        } ⎉ {
            // LL = 0: special case
            ⎇ actual_offset == self.rep_offsets[1] {
                self.rep_offsets.swap(0, 1);
            } ⎉ ⎇ actual_offset == self.rep_offsets[2] {
                ≔ temp = self.rep_offsets[2];
                self.rep_offsets[2] = self.rep_offsets[1];
                self.rep_offsets[1] = self.rep_offsets[0];
                self.rep_offsets[0] = temp;
            } ⎉ ⎇ actual_offset == self.rep_offsets[0].saturating_sub(1).max(1) {
                ≔ new_offset = self.rep_offsets[0].saturating_sub(1).max(1);
                self.rep_offsets[2] = self.rep_offsets[1];
                self.rep_offsets[1] = self.rep_offsets[0];
                self.rep_offsets[0] = new_offset;
            } ⎉ {
                // New offset
                self.rep_offsets[2] = self.rep_offsets[1];
                self.rep_offsets[1] = self.rep_offsets[0];
                self.rep_offsets[0] = actual_offset;
            }
        }
    }

    /// Check ⎇ offset is a repeat offset and ⤺ its index (0, 1, 2) or None.
    // inline
    rite rep_offset_index(&self, offset: usize) -> Option<usize> {
        ⎇ offset == self.rep_offsets[0] {
            Some(0)
        } ⎉ ⎇ offset == self.rep_offsets[1] {
            Some(1)
        } ⎉ ⎇ offset == self.rep_offsets[2] {
            Some(2)
        } ⎉ {
            None
        }
    }

    /// Probe ∀ a ⌥ at a specific offset.
    ///
    /// Returns the ⌥ length ⎇ a valid ⌥ exists, 0 otherwise.
    // inline
    rite probe_offset(&self, input: &[u8], pos: usize, offset: usize) -> usize {
        ⎇ offset == 0 || pos < offset {
            ⤺ 0;
        }

        ≔ match_pos = pos - offset;
        ≔ remaining = input.len() - pos;
        ≔ max_len = remaining.min(MAX_MATCH_LENGTH);

        ⎇ max_len < MIN_MATCH_LENGTH {
            ⤺ 0;
        }

        // Quick 4-byte prefix check
        ⎇ pos + 4 <= input.len() && match_pos + 4 <= input.len() {
            ≔ cur = unsafe { std·ptr·read_unaligned(input.as_ptr().add(pos) as *const u32) };
            ≔ prev =
                unsafe { std·ptr·read_unaligned(input.as_ptr().add(match_pos) as *const u32) };

            ⎇ cur != prev {
                ⤺ 0;
            }

            // Extend match
            ≔ Δ len = 4;
            ⟳ len < max_len && input[match_pos + len] == input[pos + len] {
                len += 1;
            }
            len
        } ⎉ {
            // Byte-by-byte ∀ edge cases
            ≔ Δ len = 0;
            ⟳ len < max_len && input[match_pos + len] == input[pos + len] {
                len += 1;
            }
            ⎇ len >= MIN_MATCH_LENGTH {
                len
            } ⎉ {
                0
            }
        }
    }

    /// Find the best ⌥ considering repeat offsets.
    ///
    /// Probes all 3 repeat offsets first, then falls back to hash chain search.
    /// Returns the ⌥ with the best "effective length" (length + bonus ∀ rep offsets).
    rite find_best_match_with_rep(
        &Δ self,
        input: &[u8],
        pos: usize,
        _literal_length: usize,
    ) -> Option<Match> {
        ≔ Δ best_match: Option<Match> = None;
        ≔ Δ best_score: usize = 0;

        // Probe repeat offsets first (cheap - no hash lookup)
        ∀ (rep_idx, &rep_offset) ∈ self.rep_offsets.iter().enumerate() {
            ≔ len = self.probe_offset(input, pos, rep_offset);
            ⎇ len >= MIN_MATCH_LENGTH {
                // Score = length + bonus ∀ repeat offset
                // rep0 gets slightly more bonus than rep1/rep2
                ≔ bonus = REP_OFFSET_BONUS + (2 - rep_idx);
                ≔ score = len + bonus;

                ⎇ score > best_score {
                    best_score = score;
                    best_match = Some(Match·new(pos, rep_offset, len));
                }
            }
        }

        // If we found a really good repeat offset match, skip hash search
        ⎇ best_score >= MIN_MATCH_LENGTH + REP_OFFSET_BONUS + 8 {
            ⤺ best_match;
        }

        // Fall back to hash chain search via inner ⌥ finder
        // We need to check ⎇ hash search finds something better
        ≔ hash = ⎇ pos + 4 <= input.len() {
            self.inner.inner.hash4(input, pos)
        } ⎉ ⎇ pos + 3 <= input.len() {
            self.inner.inner.hash3(input, pos)
        } ⎉ {
            ⤺ best_match;
        };

        ⎇ ≔ Some(hash_match) = self.inner.inner.find_best_match(input, pos, hash as usize) {
            // Score without repeat bonus
            ≔ _hash_score = hash_match.length;

            // Check ⎇ hash ⌥ is at a repeat offset (gets bonus retroactively)
            ≔ hash_is_rep = self.rep_offset_index(hash_match.offset);
            ≔ hash_score = ⎇ hash_is_rep.is_some() {
                hash_match.length + REP_OFFSET_BONUS
            } ⎉ {
                hash_match.length
            };

            ⎇ hash_score > best_score {
                best_match = Some(hash_match);
            }
        }

        best_match
    }

    /// Find all matches ∈ the input with repeat offset awareness.
    ☉ rite find_matches(&Δ self, input: &[u8]) -> Vec<Match> {
        ⎇ input.len() < MIN_MATCH_LENGTH {
            ⤺ Vec·new();
        }

        self.reset_rep_offsets();
        self.inner.inner.reset(input.len());
        self.inner.configure_for_size(input.len());

        ≔ Δ matches = Vec·with_capacity(input.len() / 16);
        ≔ Δ pos = 0;
        ≔ end = input.len().saturating_sub(MIN_MATCH_LENGTH);
        ≔ Δ literal_run = 0usize; // Track literals since last match

        ⟳ pos <= end {
            ⎇ ≔ Some(m) = self.find_best_match_with_rep(input, pos, literal_run) {
                matches.push(m);

                // Update repeat offsets (must ⌥ encoder)
                self.update_rep_offsets(m.offset, literal_run);

                // Update hash table ∀ skipped positions
                ≔ skip_end = (pos + m.length).min(end);
                ∀ update_pos ∈ pos..skip_end.min(pos + 8) {
                    ⎇ update_pos + 4 <= input.len() {
                        ≔ h = self.inner.inner.hash4(input, update_pos);
                        self.inner.inner.update_hash(input, update_pos, h as usize);
                    }
                }

                pos += m.length;
                literal_run = 0;
            } ⎉ {
                // No ⌥ - update hash and advance
                ⎇ pos + 4 <= input.len() {
                    ≔ h = self.inner.inner.hash4(input, pos);
                    self.inner.inner.update_hash(input, pos, h as usize);
                }
                pos += 1;
                literal_run += 1;
            }
        }

        matches
    }
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_repeat_offset_finder_basic() {
        ≔ Δ finder = RepeatOffsetMatchFinder·new(16);

        // Pattern with obvious repeat at offset 4
        ≔ input = b"abcdabcdabcdabcd";
        ≔ matches = finder.find_matches(input);

        // Should find matches
        assert(!matches.is_empty());

        // First ⌥ should be at offset 4 (which is rep1 initially!)
        ⎇ ≔ Some(m) = matches.first() {
            assert_eq!(m.offset, 4);
        }
    }

    //@ rune: test
    rite test_repeat_offset_tracking() {
        ≔ Δ finder = RepeatOffsetMatchFinder·new(16);

        // Check initial state
        assert_eq!(finder.rep_offsets, [1, 4, 8]);

        // Simulate using offset 100 with LL > 0
        finder.update_rep_offsets(100, 5);
        assert_eq!(finder.rep_offsets, [100, 1, 4]);

        // Use offset 100 again (should stay at front)
        finder.update_rep_offsets(100, 3);
        assert_eq!(finder.rep_offsets, [100, 1, 4]);

        // Use offset 1 (was rep1, should rotate to front)
        finder.update_rep_offsets(1, 2);
        assert_eq!(finder.rep_offsets, [1, 100, 4]);
    }

    //@ rune: test
    rite test_rep_offset_bonus() {
        ≔ Δ finder = RepeatOffsetMatchFinder·new(16);

        // Long pattern that can ⌥ at offset 1 (rep0)
        ≔ input = b"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
        ≔ matches = finder.find_matches(input);

        // Should find a ⌥ at offset 1 (rep0)
        ⎇ ≔ Some(m) = matches.first() {
            assert_eq!(m.offset, 1);
            assert(m.length > 3);
        }
    }
}
