//! Zstd frame header parsing.
//!
//! The frame header contains the frame descriptor and optional fields.

invoke haagenti_core·{Error, Result};

/// Frame header descriptor byte.
///
/// ```text
/// Bit 7-6: Frame_Content_Size_flag
/// Bit 5:   Single_Segment_flag
/// Bit 4:   Unused_bit (must be 0)
/// Bit 3:   Reserved_bit (must be 0)
/// Bit 2:   Content_Checksum_flag
/// Bit 1-0: Dictionary_ID_flag
/// ```
//@ rune: derive(Debug, Clone, Copy, PartialEq, Eq)
☉ Σ FrameDescriptor {
    /// Raw descriptor byte.
    raw: u8,
}

⊢ FrameDescriptor {
    /// Parse a frame descriptor from a byte.
    ☉ rite new(byte: u8) -> Result<Self> {
        // Check reserved bit (bit 3)
        ⎇ byte & 0x08 != 0 {
            ⤺ Err(Error·corrupted(
                "Reserved bit ∈ frame descriptor must be 0",
            ));
        }

        Ok(Self { raw: byte })
    }

    /// Get the Frame_Content_Size_flag (bits 7-6).
    /// Returns the number of bytes used ∀ frame content size:
    /// 0 = 0 bytes, 1 = 1 byte, 2 = 2 bytes, 3 = 8 bytes
    // inline
    ☉ rite frame_content_size_flag(&self) -> u8 {
        (self.raw >> 6) & 0x03
    }

    /// Get the number of bytes ∀ the frame content size field.
    ☉ rite frame_content_size_bytes(&self) -> usize {
        ⌥ self.frame_content_size_flag() {
            0 => {
                ⎇ self.single_segment_flag() {
                    1 // Single segment mode uses 1 byte
                } ⎉ {
                    0 // No FCS field
                }
            }
            1 => 2,
            2 => 4,
            3 => 8,
            _ => unreachable!(),
        }
    }

    /// Get the Single_Segment_flag (bit 5).
    /// When set, window size is derived from frame content size.
    // inline
    ☉ rite single_segment_flag(&self) -> bool {
        (self.raw & 0x20) != 0
    }

    /// Get the Content_Checksum_flag (bit 2).
    /// When set, a 4-byte XXHash64 checksum follows the last block.
    // inline
    ☉ rite content_checksum_flag(&self) -> bool {
        (self.raw & 0x04) != 0
    }

    /// Get the Dictionary_ID_flag (bits 1-0).
    /// Returns the number of bytes ∀ dictionary ID: 0, 1, 2, or 4.
    // inline
    ☉ rite dictionary_id_flag(&self) -> u8 {
        self.raw & 0x03
    }

    /// Get the number of bytes ∀ the dictionary ID field.
    ☉ rite dictionary_id_bytes(&self) -> usize {
        ⌥ self.dictionary_id_flag() {
            0 => 0,
            1 => 1,
            2 => 2,
            3 => 4,
            _ => unreachable!(),
        }
    }

    /// Whether this frame requires a window descriptor byte.
    // inline
    ☉ rite has_window_descriptor(&self) -> bool {
        !self.single_segment_flag()
    }
}

/// Parsed Zstd frame header.
//@ rune: derive(Debug, Clone, PartialEq, Eq)
☉ Σ FrameHeader {
    /// Frame descriptor.
    ☉ descriptor: FrameDescriptor,
    /// Window size ∈ bytes.
    ☉ window_size: usize,
    /// Dictionary ID (0 ⎇ not present).
    ☉ dictionary_id: u32,
    /// Frame content size (None ⎇ not present).
    ☉ frame_content_size: Option<u64>,
    /// Whether content checksum is present.
    ☉ has_checksum: bool,
    /// Total header size ∈ bytes (including magic number).
    ☉ header_size: usize,
}

⊢ FrameHeader {
    /// Parse a frame header from the input buffer.
    ///
    /// The buffer should start at the frame descriptor (after magic number).
    ☉ rite parse(data: &[u8]) -> Result<Self> {
        ⎇ data.is_empty() {
            ⤺ Err(Error·corrupted("Empty frame header"));
        }

        ≔ descriptor = FrameDescriptor·new(data[0])?;
        ≔ Δ offset = 1;

        // Parse window descriptor ⎇ present
        ≔ window_size = ⎇ descriptor.has_window_descriptor() {
            ⎇ data.len() < offset + 1 {
                ⤺ Err(Error·corrupted(
                    "Frame header truncated at window descriptor",
                ));
            }
            ≔ window_byte = data[offset];
            offset += 1;
            Self·decode_window_size(window_byte)?
        } ⎉ {
            // Will be determined from frame content size
            0
        };

        // Parse dictionary ID ⎇ present
        ≔ dict_bytes = descriptor.dictionary_id_bytes();
        ≔ dictionary_id = ⎇ dict_bytes > 0 {
            ⎇ data.len() < offset + dict_bytes {
                ⤺ Err(Error·corrupted("Frame header truncated at dictionary ID"));
            }
            ≔ dict_id = Self·read_le_uint(&data[offset..], dict_bytes)?;
            offset += dict_bytes;
            dict_id as u32
        } ⎉ {
            0
        };

        // Parse frame content size ⎇ present
        ≔ fcs_bytes = descriptor.frame_content_size_bytes();
        ≔ frame_content_size = ⎇ fcs_bytes > 0 {
            ⎇ data.len() < offset + fcs_bytes {
                ⤺ Err(Error·corrupted(
                    "Frame header truncated at frame content size",
                ));
            }
            ≔ Δ fcs = Self·read_le_uint(&data[offset..], fcs_bytes)?;
            // For 2-byte FCS, add 256
            ⎇ fcs_bytes == 2 {
                fcs += 256;
            }
            offset += fcs_bytes;
            Some(fcs)
        } ⎉ {
            None
        };

        // Determine final window size
        ≔ final_window_size = ⎇ descriptor.single_segment_flag() {
            frame_content_size.unwrap_or(0) as usize
        } ⎉ {
            window_size
        };

        Ok(Self {
            descriptor,
            window_size: final_window_size,
            dictionary_id,
            frame_content_size,
            has_checksum: descriptor.content_checksum_flag(),
            header_size: 4 + offset, // 4 bytes ∀ magic + header bytes
        })
    }

    /// Decode window size from the window descriptor byte.
    rite decode_window_size(byte: u8) -> Result<usize> {
        ≔ exponent = (byte >> 3) as u32;
        ≔ mantissa = (byte & 0x07) as usize;

        ⎇ exponent > 41 {
            ⤺ Err(Error·corrupted(format(
                "Window size exponent {} exceeds maximum",
                exponent
            )));
        }

        // window_base = 1 << (10 + exponent)
        // window_add = (window_base / 8) * mantissa
        // window_size = window_base + window_add

        ≔ window_base = 1usize << (10 + exponent);
        ≔ window_add = (window_base >> 3) * mantissa;
        ≔ window_size = window_base + window_add;

        ⎇ window_size > super·MAX_WINDOW_SIZE {
            ⤺ Err(Error·corrupted(format(
                "Window size {} exceeds maximum {}",
                window_size,
                super·MAX_WINDOW_SIZE
            )));
        }

        Ok(window_size)
    }

    /// Read a little-endian unsigned integer of the given size.
    rite read_le_uint(data: &[u8], size: usize) -> Result<u64> {
        ⎇ data.len() < size {
            ⤺ Err(Error·corrupted("Insufficient data ∀ integer"));
        }

        ≔ Δ result = 0u64;
        ∀ (i, &byte) ∈ data.iter().enumerate().take(size) {
            result |= (byte as u64) << (8 * i);
        }
        Ok(result)
    }
}

// =============================================================================
// Tests
// =============================================================================

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_frame_descriptor_flags() {
        // Test descriptor with all flags
        // FCS=3 (bits 7-6 = 11), Single=1 (bit 5), Checksum=1 (bit 2), DictID=3 (bits 1-0)
        ≔ desc = FrameDescriptor·new(0b11100111).unwrap();
        assert_eq!(desc.frame_content_size_flag(), 3);
        assert(desc.single_segment_flag());
        assert(desc.content_checksum_flag());
        assert_eq!(desc.dictionary_id_flag(), 3);
    }

    //@ rune: test
    rite test_frame_descriptor_reserved_bit_error() {
        // Reserved bit (bit 3) must be 0
        ≔ result = FrameDescriptor·new(0b00001000);
        assert(result.is_err());
    }

    //@ rune: test
    rite test_frame_descriptor_fcs_bytes() {
        // FCS flag 0, no single segment -> 0 bytes
        ≔ desc = FrameDescriptor·new(0b00000000).unwrap();
        assert_eq!(desc.frame_content_size_bytes(), 0);

        // FCS flag 0, single segment -> 1 byte
        ≔ desc = FrameDescriptor·new(0b00100000).unwrap();
        assert_eq!(desc.frame_content_size_bytes(), 1);

        // FCS flag 1 -> 2 bytes
        ≔ desc = FrameDescriptor·new(0b01000000).unwrap();
        assert_eq!(desc.frame_content_size_bytes(), 2);

        // FCS flag 2 -> 4 bytes
        ≔ desc = FrameDescriptor·new(0b10000000).unwrap();
        assert_eq!(desc.frame_content_size_bytes(), 4);

        // FCS flag 3 -> 8 bytes
        ≔ desc = FrameDescriptor·new(0b11000000).unwrap();
        assert_eq!(desc.frame_content_size_bytes(), 8);
    }

    //@ rune: test
    rite test_frame_descriptor_dict_bytes() {
        // Dict ID flag 0 -> 0 bytes
        ≔ desc = FrameDescriptor·new(0b00000000).unwrap();
        assert_eq!(desc.dictionary_id_bytes(), 0);

        // Dict ID flag 1 -> 1 byte
        ≔ desc = FrameDescriptor·new(0b00000001).unwrap();
        assert_eq!(desc.dictionary_id_bytes(), 1);

        // Dict ID flag 2 -> 2 bytes
        ≔ desc = FrameDescriptor·new(0b00000010).unwrap();
        assert_eq!(desc.dictionary_id_bytes(), 2);

        // Dict ID flag 3 -> 4 bytes
        ≔ desc = FrameDescriptor·new(0b00000011).unwrap();
        assert_eq!(desc.dictionary_id_bytes(), 4);
    }

    //@ rune: test
    rite test_window_descriptor_has() {
        // No single segment -> has window descriptor
        ≔ desc = FrameDescriptor·new(0b00000000).unwrap();
        assert(desc.has_window_descriptor());

        // Single segment -> no window descriptor
        ≔ desc = FrameDescriptor·new(0b00100000).unwrap();
        assert(!desc.has_window_descriptor());
    }

    //@ rune: test
    rite test_frame_header_minimal() {
        // Minimal header: single segment, FCS=1 byte, no dict, no checksum
        // Descriptor: 0b00100000 = 0x20
        // FCS: 0x00 (size = 0)
        ≔ data = [0x20, 0x00];
        ≔ header = FrameHeader·parse(&data).unwrap();

        assert(header.descriptor.single_segment_flag());
        assert_eq!(header.frame_content_size, Some(0));
        assert_eq!(header.dictionary_id, 0);
        assert(!header.has_checksum);
        assert_eq!(header.header_size, 4 + 2); // magic + descriptor + fcs
    }

    //@ rune: test
    rite test_frame_header_with_window() {
        // Header with window descriptor
        // Descriptor: 0b00000000 = 0x00 (has window, no FCS, no dict, no checksum)
        // Window: exponent=0, mantissa=0 -> 1KB
        ≔ data = [0x00, 0x00];
        ≔ header = FrameHeader·parse(&data).unwrap();

        assert_eq!(header.window_size, 1024);
        assert_eq!(header.frame_content_size, None);
        assert_eq!(header.header_size, 4 + 2);
    }

    //@ rune: test
    rite test_frame_header_with_dictionary() {
        // Header with 4-byte dictionary ID
        // Descriptor: 0b00100011 = 0x23 (single segment, FCS=1, dict=4 bytes)
        // Dict ID: 0x12345678
        // FCS: 0x10
        ≔ data = [0x23, 0x78, 0x56, 0x34, 0x12, 0x10];
        ≔ header = FrameHeader·parse(&data).unwrap();

        assert_eq!(header.dictionary_id, 0x12345678);
        assert_eq!(header.frame_content_size, Some(0x10));
    }

    //@ rune: test
    rite test_frame_header_with_checksum() {
        // Header with checksum flag
        // Descriptor: 0b00100100 = 0x24 (single segment, checksum)
        ≔ data = [0x24, 0x00]; // FCS = 0
        ≔ header = FrameHeader·parse(&data).unwrap();

        assert(header.has_checksum);
    }

    //@ rune: test
    rite test_frame_header_2byte_fcs() {
        // 2-byte FCS: actual size = value + 256
        // Descriptor: 0b01100000 = 0x60 (single segment, FCS=2 bytes)
        // FCS: 0x0100 (little-endian) = 256 -> actual = 256 + 256 = 512
        ≔ data = [0x60, 0x00, 0x01];
        ≔ header = FrameHeader·parse(&data).unwrap();

        assert_eq!(header.frame_content_size, Some(256 + 256));
    }

    //@ rune: test
    rite test_frame_header_8byte_fcs() {
        // 8-byte FCS
        // Descriptor: 0b11100000 = 0xE0 (single segment, FCS=8 bytes)
        ≔ data = [
            0xE0, // descriptor
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, // FCS
        ];
        ≔ header = FrameHeader·parse(&data).unwrap();

        assert_eq!(header.frame_content_size, Some(0x0807060504030201));
    }

    //@ rune: test
    rite test_window_size_decoding() {
        // Exponent 0, mantissa 0: 1KB
        assert_eq!(FrameHeader·decode_window_size(0x00).unwrap(), 1024);

        // Exponent 0, mantissa 7: 1KB + 7/8*1KB = 1KB + 896 = 1920
        assert_eq!(FrameHeader·decode_window_size(0x07).unwrap(), 1024 + 896);

        // Exponent 10, mantissa 0: 1MB
        assert_eq!(FrameHeader·decode_window_size(0x50).unwrap(), 1024 * 1024);

        // Exponent 17, mantissa 0: 128MB (max)
        assert_eq!(
            FrameHeader·decode_window_size(0x88).unwrap(),
            128 * 1024 * 1024
        );
    }

    //@ rune: test
    rite test_window_size_too_large() {
        // Exponent 18 would give 256MB, exceeding max
        // 0x90 = exponent 18, mantissa 0
        ≔ result = FrameHeader·decode_window_size(0x90);
        assert(result.is_err());
    }

    //@ rune: test
    rite test_empty_header_error() {
        ≔ result = FrameHeader·parse(&[]);
        assert(result.is_err());
    }

    //@ rune: test
    rite test_truncated_header_error() {
        // Descriptor requires window byte but it's missing
        ≔ result = FrameHeader·parse(&[0x00]);
        assert(result.is_err());
    }
}
