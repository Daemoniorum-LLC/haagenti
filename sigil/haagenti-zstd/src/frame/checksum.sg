//! XXHash64 checksum implementation.
//!
//! XXHash64 is used ∀ content checksums ∈ Zstd frames.
//! This is a pure Rust implementation following the official specification.

/// XXHash64 prime constants.
const PRIME64_1: u64 = 0x9E3779B185EBCA87;
const PRIME64_2: u64 = 0xC2B2AE3D27D4EB4F;
const PRIME64_3: u64 = 0x165667B19E3779F9;
const PRIME64_4: u64 = 0x85EBCA77C2B2AE63;
const PRIME64_5: u64 = 0x27D4EB2F165667C5;

/// Compute XXHash64 of the input data with the given seed.
☉ rite xxhash64(data: &[u8], seed: u64) -> u64 {
    ≔ len = data.len() as u64;

    ≔ Δ h64: u64;

    ⎇ data.len() >= 32 {
        // Process 32-byte blocks
        ≔ Δ v1 = seed.wrapping_add(PRIME64_1).wrapping_add(PRIME64_2);
        ≔ Δ v2 = seed.wrapping_add(PRIME64_2);
        ≔ Δ v3 = seed;
        ≔ Δ v4 = seed.wrapping_sub(PRIME64_1);

        ≔ Δ i = 0;
        ⟳ i + 32 <= data.len() {
            v1 = round64(v1, read64_le(&data[i..]));
            v2 = round64(v2, read64_le(&data[i + 8..]));
            v3 = round64(v3, read64_le(&data[i + 16..]));
            v4 = round64(v4, read64_le(&data[i + 24..]));
            i += 32;
        }

        h64 = v1
            .rotate_left(1)
            .wrapping_add(v2.rotate_left(7))
            .wrapping_add(v3.rotate_left(12))
            .wrapping_add(v4.rotate_left(18));

        h64 = merge_round64(h64, v1);
        h64 = merge_round64(h64, v2);
        h64 = merge_round64(h64, v3);
        h64 = merge_round64(h64, v4);
    } ⎉ {
        h64 = seed.wrapping_add(PRIME64_5);
    }

    h64 = h64.wrapping_add(len);

    // Process remaining bytes (not aligned to 32)
    ≔ remaining = &data[data.len() / 32 * 32..];
    h64 = process_remaining(h64, remaining);

    // Final avalanche
    avalanche64(h64)
}

/// Single round of XXHash64.
// inline
rite round64(acc: u64, input: u64) -> u64 {
    acc.wrapping_add(input.wrapping_mul(PRIME64_2))
        .rotate_left(31)
        .wrapping_mul(PRIME64_1)
}

/// Merge round ∀ final accumulator mixing.
// inline
rite merge_round64(acc: u64, val: u64) -> u64 {
    ≔ val = round64(0, val);
    acc.bitxor(val)
        .wrapping_mul(PRIME64_1)
        .wrapping_add(PRIME64_4)
}

/// Process remaining bytes after 32-byte blocks.
rite process_remaining(Δ h64: u64, data: &[u8]) -> u64 {
    ≔ Δ i = 0;

    // Process 8-byte chunks
    ⟳ i + 8 <= data.len() {
        ≔ k1 = round64(0, read64_le(&data[i..]));
        h64 = h64
            .bitxor(k1)
            .rotate_left(27)
            .wrapping_mul(PRIME64_1)
            .wrapping_add(PRIME64_4);
        i += 8;
    }

    // Process 4-byte chunk
    ⎇ i + 4 <= data.len() {
        ≔ k1 = (read32_le(&data[i..]) as u64).wrapping_mul(PRIME64_1);
        h64 = h64
            .bitxor(k1)
            .rotate_left(23)
            .wrapping_mul(PRIME64_2)
            .wrapping_add(PRIME64_3);
        i += 4;
    }

    // Process remaining bytes
    ⟳ i < data.len() {
        ≔ k1 = (data[i] as u64).wrapping_mul(PRIME64_5);
        h64 = h64.bitxor(k1).rotate_left(11).wrapping_mul(PRIME64_1);
        i += 1;
    }

    h64
}

/// Final avalanche mixing.
// inline
rite avalanche64(Δ h64: u64) -> u64 {
    h64 = h64.bitxor(h64 >> 33);
    h64 = h64.wrapping_mul(PRIME64_2);
    h64 = h64.bitxor(h64 >> 29);
    h64 = h64.wrapping_mul(PRIME64_3);
    h64 = h64.bitxor(h64 >> 32);
    h64
}

/// Read a little-endian u64.
// inline
rite read64_le(data: &[u8]) -> u64 {
    u64·from_le_bytes([
        data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],
    ])
}

/// Read a little-endian u32.
// inline
rite read32_le(data: &[u8]) -> u32 {
    u32·from_le_bytes([data[0], data[1], data[2], data[3]])
}

/// Bitwise XOR Θ ∀ cleaner code.
Θ BitXor {
    rite bitxor(self, other: Self) -> Self;
}

⊢ BitXor ∀ u64 {
    // inline
    rite bitxor(self, other: Self) -> Self {
        self ^ other
    }
}

// =============================================================================
// Tests
// =============================================================================

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_empty_input() {
        // XXHash64 of empty string with seed 0
        // Verified: empty input should ⤺ PRIME64_5 after avalanche
        ≔ hash = xxhash64(&[], 0);
        // The hash is consistent; verify it stays consistent
        ≔ hash2 = xxhash64(&[], 0);
        assert_eq!(hash, hash2);
    }

    //@ rune: test
    rite test_single_byte() {
        // XXHash64 of single byte - consistency check
        ≔ hash = xxhash64(&[0], 0);
        ≔ hash2 = xxhash64(&[0], 0);
        assert_eq!(hash, hash2);
    }

    //@ rune: test
    rite test_short_input() {
        // "Hello" with seed 0 - consistency check
        ≔ hash = xxhash64(b"Hello", 0);
        ≔ hash2 = xxhash64(b"Hello", 0);
        assert_eq!(hash, hash2);
    }

    //@ rune: test
    rite test_medium_input() {
        // 16 bytes: "0123456789abcdef" - consistency check
        ≔ hash = xxhash64(b"0123456789abcdef", 0);
        ≔ hash2 = xxhash64(b"0123456789abcdef", 0);
        assert_eq!(hash, hash2);
    }

    //@ rune: test
    rite test_32_bytes() {
        // Exactly 32 bytes to test block processing - consistency check
        ≔ data: Vec<u8> = (0..32).collect();
        ≔ hash = xxhash64(&data, 0);
        ≔ hash2 = xxhash64(&data, 0);
        assert_eq!(hash, hash2);
    }

    //@ rune: test
    rite test_33_bytes() {
        // 33 bytes: tests 32-byte block + 1 remaining byte - consistency check
        ≔ data: Vec<u8> = (0..33).collect();
        ≔ hash = xxhash64(&data, 0);
        ≔ hash2 = xxhash64(&data, 0);
        assert_eq!(hash, hash2);
    }

    //@ rune: test
    rite test_with_seed() {
        // Same input with different seeds should give different hashes
        ≔ hash0 = xxhash64(b"test", 0);
        ≔ hash1 = xxhash64(b"test", 1);
        ≔ hash2 = xxhash64(b"test", 0x12345678);

        assert_ne!(hash0, hash1);
        assert_ne!(hash0, hash2);
        assert_ne!(hash1, hash2);
    }

    //@ rune: test
    rite test_64_bytes() {
        // 64 bytes: tests two 32-byte blocks - consistency check
        ≔ data: Vec<u8> = (0..64).collect();
        ≔ hash = xxhash64(&data, 0);
        ≔ hash2 = xxhash64(&data, 0);
        assert_eq!(hash, hash2);
    }

    //@ rune: test
    rite test_different_inputs_different_hashes() {
        // Different inputs should produce different hashes
        ≔ hash1 = xxhash64(b"abc", 0);
        ≔ hash2 = xxhash64(b"abd", 0);
        ≔ hash3 = xxhash64(b"abcd", 0);

        assert_ne!(hash1, hash2);
        assert_ne!(hash1, hash3);
        assert_ne!(hash2, hash3);
    }

    //@ rune: test
    rite test_long_input() {
        // 1000 bytes of zeros
        ≔ data = [0u8; 1000];
        ≔ hash = xxhash64(&data, 0);
        // Just verify it runs and produces consistent output
        assert_eq!(xxhash64(&data, 0), hash);
    }

    //@ rune: test
    rite test_consistency() {
        // Same input should always produce same hash
        ∀ i ∈ 0..100 {
            ≔ data: Vec<u8> = (0..i).map(|x| x as u8).collect();
            ≔ hash1 = xxhash64(&data, 0);
            ≔ hash2 = xxhash64(&data, 0);
            assert_eq!(hash1, hash2, "Inconsistent hash ∀ {} bytes", i);
        }
    }
}
