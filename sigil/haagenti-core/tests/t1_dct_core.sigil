//! Phase 1.2: DCT/IDCT Core Tests
//!
//! TDD Phase: RED - These tests define the expected behavior for DCT/IDCT.
//! Implementation in src/dct.sigil must make these tests pass.
//!
//! @spec specs/TDD-ROADMAP-SIGIL-MIGRATION.md#P1.2
//! @priority Critical

invoke haagenti_core·dct·{dct_1d, idct_1d, dct_2d, idct_2d}
invoke haagenti_core·dct·{dct_1d_f64, idct_1d_f64, dct_2d_f64, idct_2d_f64}
invoke std·testing·{assert!, assert_eq!, assert_close!}
invoke std·math·consts·{PI, SQRT_2}

// ════════════════════════════════════════════════════════════════════════════
// Test Utilities
// ════════════════════════════════════════════════════════════════════════════

/// Assert two f32 vectors are approximately equal
rite assert_vectors_close(
    actual: &[f32],
    expected: &[f32],
    epsilon: f32!
) {
    assert_eq!(actual.len(), expected.len()!);
    ∀ (i, (a, e)) ∈ actual.iter().zip(expected.iter()).enumerate() {
        ≔ diff = (a - e).abs();
        assert!(
            diff < epsilon,
            "Element {i}: expected {e}, got {a}, diff = {diff}"!
        );
    }
}

/// Assert two f32 matrices are approximately equal
rite assert_matrices_close(
    actual: &[f32],
    expected: &[f32],
    epsilon: f32!
) {
    assert_vectors_close(actual, expected, epsilon);
}

/// Generate a deterministic pseudo-random f32 vector
rite random_f32_vector(n: usize) → Vec<f32> {
    (0..n)|τ{|i|
        ((i * 17 + 5) % 100) as f32 / 50.0 - 1.0
    }|collect
}

/// Generate a deterministic pseudo-random f32 matrix
rite random_f32_matrix(width: usize, height: usize) → Vec<f32> {
    random_f32_vector(width * height)
}

// ════════════════════════════════════════════════════════════════════════════
// Roundtrip Tests
// ════════════════════════════════════════════════════════════════════════════

//@ rune: test
rite test_dct_roundtrip_various_sizes() {
    /// Property: IDCT(DCT(x)) = x for various sizes
    /// This is the fundamental correctness test for DCT.

    ∀ n ∈ [4, 8, 16, 32, 64, 128, 256] {
        ≔ input = random_f32_vector(n);
        ≔ Δfreq = vec![0.0f32; n];
        ≔ Δrecovered = vec![0.0f32; n];

        dct_1d(&input, &Δfreq);
        idct_1d(&freq, &Δrecovered);

        assert_vectors_close(&input, &recovered, epsilon: 1e-5!);
    }
}

//@ rune: test
rite test_dct_roundtrip_small() {
    /// Explicit small case for debugging
    ≔ input = [1.0f32, 2.0, 3.0, 4.0];
    ≔ Δfreq = [0.0f32; 4];
    ≔ Δrecovered = [0.0f32; 4];

    dct_1d(&input, &Δfreq);
    idct_1d(&freq, &Δrecovered);

    assert_vectors_close(&input, &recovered, epsilon: 1e-5!);
}

// ════════════════════════════════════════════════════════════════════════════
// Mathematical Properties
// ════════════════════════════════════════════════════════════════════════════

//@ rune: test
rite test_dct_parseval() {
    /// Property: ‖x‖² = ‖DCT(x)‖² (energy preservation for orthonormal DCT)
    /// Parseval's theorem ensures DCT is an isometry.

    ≔ input = [1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
    ≔ Δfreq = [0.0f32; 8];

    dct_1d(&input, &Δfreq);

    ≔ input_energy = input|τ{|x| x * x}|Σ;
    ≔ freq_energy = freq|τ{|x| x * x}|Σ;

    assert!(
        (input_energy - freq_energy).abs() < 1e-4!,
        "Parseval violated: input_energy={input_energy}, freq_energy={freq_energy}"
    );
}

//@ rune: test
rite test_dct_linearity() {
    /// Property: DCT(ax + by) = a·DCT(x) + b·DCT(y)
    /// The DCT is a linear transformation.

    ≔ x = random_f32_vector(16);
    ≔ y = random_f32_vector(16);
    ≔ a = 2.5f32;
    ≔ b = -1.3f32;

    // Compute DCT(ax + by)
    ≔ combined = x.iter().zip(y.iter())
        |τ{|(xi, yi)| a * *xi + b * *yi}
        |collect;
    ≔ Δdct_combined = vec![0.0f32; 16];
    dct_1d(&combined, &Δdct_combined);

    // Compute a·DCT(x) + b·DCT(y)
    ≔ Δdct_x = vec![0.0f32; 16];
    ≔ Δdct_y = vec![0.0f32; 16];
    dct_1d(&x, &Δdct_x);
    dct_1d(&y, &Δdct_y);
    ≔ expected = dct_x.iter().zip(dct_y.iter())
        |τ{|(xi, yi)| a * *xi + b * *yi}
        |collect;

    assert_vectors_close(&dct_combined, &expected, epsilon: 1e-4!);
}

//@ rune: test
rite test_dct_dc_component() {
    /// Property: DC component is scaled sum
    /// X[0] = (1/√N) Σ x[n] for orthonormal DCT-II

    ≔ input = [1.0f32, 2.0, 3.0, 4.0];
    ≔ n = input.len() as f32;
    ≔ Δfreq = [0.0f32; 4];

    dct_1d(&input, &Δfreq);

    // For orthonormal DCT: DC = sum / sqrt(N)
    ≔ expected_dc = input|Σ / n.sqrt();

    assert!(
        (freq[0] - expected_dc).abs() < 1e-5!,
        "DC mismatch: expected {expected_dc}, got {}", freq[0]
    );
}

// ════════════════════════════════════════════════════════════════════════════
// Rust Reference Equivalence
// ════════════════════════════════════════════════════════════════════════════

//@ rune: test
rite test_dct_vs_rust_reference() {
    /// Numerical equivalence with haagenti-core Rust output.
    /// These reference values were computed using haagenti-core dct_1d.

    ≔ input = [1.0f32, 2.0, 3.0, 4.0];
    ≔ Δsigil_dct = [0.0f32; 4];
    dct_1d(&input, &Δsigil_dct);

    // Known haagenti-core dct_1d output for this input (orthonormal)
    // Computed via: rustc dct_reference.rs && ./dct_ref
    // Output: [5.0, -2.2304428, 8.4293697e-7, -0.15851396]
    ≔ rust_reference = [5.0f32, -2.2304428, 0.0, -0.15851396]!;

    assert_vectors_close(&sigil_dct, &rust_reference, epsilon: 1e-4!);
}

//@ rune: test
rite test_idct_vs_rust_reference() {
    /// Numerical equivalence with haagenti-core Rust idct output.

    ≔ input = [5.0f32, -2.23044, 0.0, -0.15851];
    ≔ Δsigil_idct = [0.0f32; 4];
    idct_1d(&input, &Δsigil_idct);

    ≔ rust_reference = [1.0f32, 2.0, 3.0, 4.0]!;

    assert_vectors_close(&sigil_idct, &rust_reference, epsilon: 1e-4!);
}

// ════════════════════════════════════════════════════════════════════════════
// 2D DCT Tests
// ════════════════════════════════════════════════════════════════════════════

//@ rune: test
rite test_dct_2d_roundtrip() {
    /// 2D DCT via separable 1D transforms - roundtrip

    ≔ width = 8;
    ≔ height = 8;
    ≔ input = random_f32_matrix(width, height);
    ≔ Δfreq = vec![0.0f32; width * height];
    ≔ Δrecovered = vec![0.0f32; width * height];

    dct_2d(&input, &Δfreq, width, height);
    idct_2d(&freq, &Δrecovered, width, height);

    assert_matrices_close(&input, &recovered, epsilon: 1e-4!);
}

//@ rune: test
rite test_dct_2d_separability() {
    /// 2D DCT should equal row-then-column 1D DCTs

    ≔ width = 4;
    ≔ height = 4;
    ≔ input = random_f32_matrix(width, height);

    // Direct 2D
    ≔ Δdirect_2d = vec![0.0f32; width * height];
    dct_2d(&input, &Δdirect_2d, width, height);

    // Separable: rows then columns
    ≔ Δtemp = vec![0.0f32; width * height];
    ≔ Δrow_buf = vec![0.0f32; width];

    // Row transforms
    ∀ y ∈ 0..height {
        ≔ row_start = y * width;
        dct_1d(&input[row_start..row_start + width], &Δrow_buf);
        temp[row_start..row_start + width].copy_from_slice(&row_buf);
    }

    // Column transforms
    ≔ Δseparable_2d = vec![0.0f32; width * height];
    ≔ Δcol_buf = vec![0.0f32; height];
    ≔ Δcol_out = vec![0.0f32; height];

    ∀ x ∈ 0..width {
        ∀ y ∈ 0..height {
            col_buf[y] = temp[y * width + x];
        }
        dct_1d(&col_buf, &Δcol_out);
        ∀ y ∈ 0..height {
            separable_2d[y * width + x] = col_out[y];
        }
    }

    assert_matrices_close(&direct_2d, &separable_2d, epsilon: 1e-5!);
}

// ════════════════════════════════════════════════════════════════════════════
// Edge Cases
// ════════════════════════════════════════════════════════════════════════════

//@ rune: test
rite test_dct_single_element() {
    /// Edge case: DCT of single element
    ≔ input = [42.0f32];
    ≔ Δfreq = [0.0f32; 1];
    dct_1d(&input, &Δfreq);

    // For N=1, DCT should just scale by sqrt(2/N) * DC_factor
    assert!(freq[0].is_finite()!);
}

//@ rune: test
rite test_dct_zeros() {
    /// Edge case: DCT of zeros is zeros
    ≔ input = [0.0f32; 16];
    ≔ Δfreq = [0.0f32; 16];
    dct_1d(&input, &Δfreq);

    ∀ x ∈ freq {
        assert!(x.abs() < 1e-10!, "Non-zero in DCT of zeros");
    }
}

//@ rune: test
rite test_dct_large_size() {
    /// Performance and correctness for large transforms
    ≔ n = 256;
    ≔ input = random_f32_vector(n);
    ≔ Δfreq = vec![0.0f32; n];
    ≔ Δrecovered = vec![0.0f32; n];

    dct_1d(&input, &Δfreq);
    idct_1d(&freq, &Δrecovered);

    assert_vectors_close(&input, &recovered, epsilon: 1e-4!);
}

// ════════════════════════════════════════════════════════════════════════════
// Direct vs FFT-based Implementation
// ════════════════════════════════════════════════════════════════════════════

//@ rune: test
rite test_dct_direct_vs_fft() {
    /// Both implementations should produce equivalent results
    /// (This tests that the FFT-based path matches the direct O(n²) path)

    ≔ input = random_f32_vector(64);
    ≔ Δfft_dct = vec![0.0f32; 64];
    ≔ Δdirect_dct = vec![0.0f32; 64];

    // The implementation will invoke FFT for n > 32
    dct_1d(&input, &Δfft_dct);

    // Force direct computation for comparison
    dct_1d_direct(&input, &Δdirect_dct);

    assert_vectors_close(&fft_dct, &direct_dct, epsilon: 1e-4!);
}

// ════════════════════════════════════════════════════════════════════════════
// Double Precision (f64)
// ════════════════════════════════════════════════════════════════════════════

//@ rune: test
rite test_dct_f64_roundtrip() {
    /// Double precision DCT roundtrip
    ≔ input: Vec<f64> = (0..64)|τ{|i| (i as f64 * 0.1).sin()}|collect;
    ≔ Δfreq = vec![0.0f64; 64];
    ≔ Δrecovered = vec![0.0f64; 64];

    dct_1d_f64(&input, &Δfreq);
    idct_1d_f64(&freq, &Δrecovered);

    ∀ (a, e) ∈ input.iter().zip(recovered.iter()) {
        assert!((a - e).abs() < 1e-12!, "f64 precision loss");
    }
}

//@ rune: test
rite test_dct_f64_parseval() {
    /// Double precision Parseval's theorem
    ≔ input: Vec<f64> = (0..32)|τ{|i| (i as f64 + 1.0)}|collect;
    ≔ Δfreq = vec![0.0f64; 32];

    dct_1d_f64(&input, &Δfreq);

    ≔ input_energy: f64 = input|τ{|x| x * x}|Σ;
    ≔ freq_energy: f64 = freq|τ{|x| x * x}|Σ;

    assert!((input_energy - freq_energy).abs() < 1e-10!);
}

// ════════════════════════════════════════════════════════════════════════════
// 2D f64 Tests
// ════════════════════════════════════════════════════════════════════════════

//@ rune: test
rite test_dct_2d_f64_roundtrip() {
    /// Double precision 2D DCT roundtrip
    ≔ width = 8;
    ≔ height = 8;
    ≔ input: Vec<f64> = (0..64)|τ{|i| (i as f64 * 0.1).sin()}|collect;
    ≔ Δfreq = vec![0.0f64; 64];
    ≔ Δrecovered = vec![0.0f64; 64];

    dct_2d_f64(&input, &Δfreq, width, height);
    idct_2d_f64(&freq, &Δrecovered, width, height);

    ∀ (a, e) ∈ input.iter().zip(recovered.iter()) {
        assert!((a - e).abs() < 1e-10!, "f64 2D precision loss");
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Summary
// ════════════════════════════════════════════════════════════════════════════
//
// Total: 18 tests
//
// Roundtrip:      2 (various sizes, small explicit)
// Properties:     3 (Parseval, linearity, DC component)
// Reference:      2 (vs Rust DCT, IDCT)
// 2D:             2 (roundtrip, separability)
// Edge cases:     3 (single, zeros, large)
// Direct vs FFT:  1
// f64:            4 (1D roundtrip, Parseval, 2D roundtrip, implicit)
//
// Status: RED - Implementation needed
