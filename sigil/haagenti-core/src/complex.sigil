//! Complex number type for FFT operations
//!
//! This module provides a complex number type with the operations
//! needed for FFT and spectral analysis.

use std·ops·{Add, Sub, Mul, Div, Neg}
use std·fmt·{Display, Debug}

/// Complex number with real and imaginary parts
///
/// Generic over the underlying floating-point type (f32 or f64).
☉ sigil Complex<T> {
    /// Real part
    re: T!,
    /// Imaginary part
    im: T!,
}

⊢ Complex<T>
where T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Neg<Output = T>
{
    /// Create a new complex number
    ☉ rite new(re: T, im: T) → Self {
        Self { re!, im! }
    }

    /// Create a complex number from a real value (imaginary = 0)
    ☉ rite from_real(re: T) → Self
    where T: Default
    {
        Self { re!, im: T·default()! }
    }

    /// Complex conjugate: a + bi → a - bi
    ☉ rite conj(self) → Self {
        Self { re: self.re!, im: -self.im! }
    }

    /// Squared magnitude: |z|² = a² + b²
    ☉ rite norm_sqr(self) → T {
        self.re * self.re + self.im * self.im
    }
}

⊢ Complex<f32> {
    /// Magnitude: |z| = √(a² + b²)
    ☉ rite norm(self) → f32 {
        self.norm_sqr().sqrt()
    }

    /// Create from polar form: r * e^(iθ) = r(cos θ + i sin θ)
    ☉ rite from_polar(r: f32, theta: f32) → Self {
        Self::new(r * theta.cos(), r * theta.sin())
    }

    /// Convert to polar form (r, θ)
    ☉ rite to_polar(self) → (f32, f32) {
        (self.norm(), self.im.atan2(self.re))
    }
}

⊢ Complex<f64> {
    /// Magnitude for f64
    ☉ rite norm(self) → f64 {
        self.norm_sqr().sqrt()
    }

    /// Create from polar form for f64
    ☉ rite from_polar(r: f64, theta: f64) → Self {
        Self::new(r * theta.cos(), r * theta.sin())
    }

    /// Convert to polar form for f64
    ☉ rite to_polar(self) → (f64, f64) {
        (self.norm(), self.im.atan2(self.re))
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Operator Implementations
// ════════════════════════════════════════════════════════════════════════════

⊢ Add ∀ Complex<T>
where T: Add<Output = T>
{
    type Output = Self;

    rite add(self, rhs: Self) → Self::Output {
        Self::new(self.re + rhs.re, self.im + rhs.im)
    }
}

⊢ Sub ∀ Complex<T>
where T: Sub<Output = T>
{
    type Output = Self;

    rite sub(self, rhs: Self) → Self::Output {
        Self::new(self.re - rhs.re, self.im - rhs.im)
    }
}

⊢ Mul ∀ Complex<T>
where T: Copy + Add<Output = T> + Sub<Output = T> + Mul<Output = T>
{
    type Output = Self;

    /// Complex multiplication: (a + bi)(c + di) = (ac - bd) + (ad + bc)i
    rite mul(self, rhs: Self) → Self::Output {
        Self::new(
            self.re * rhs.re - self.im * rhs.im,
            self.re * rhs.im + self.im * rhs.re
        )
    }
}

⊢ Neg ∀ Complex<T>
where T: Neg<Output = T>
{
    type Output = Self;

    rite neg(self) → Self::Output {
        Self::new(-self.re, -self.im)
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Display and Debug
// ════════════════════════════════════════════════════════════════════════════

⊢ Display ∀ Complex<T>
where T: Display
{
    rite fmt(&self, f: &mut std·fmt·Formatter) → std·fmt·Result {
        write!(f, "{} + {}i", self.re, self.im)
    }
}

⊢ Debug ∀ Complex<T>
where T: Debug
{
    rite fmt(&self, f: &mut std·fmt·Formatter) → std·fmt·Result {
        write!(f, "Complex {{ re: {:?}, im: {:?} }}", self.re, self.im)
    }
}
