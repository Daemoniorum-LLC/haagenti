//! Compression Traits for Haagenti
//!
//! This module defines the trait interfaces for compressors and decompressors,
//! enabling polymorphic compression pipelines.

use super·types·CompressionStats
use super·error·Result

// ════════════════════════════════════════════════════════════════════════════
// Compressor Trait
// ════════════════════════════════════════════════════════════════════════════

/// Interface for compression algorithms.
///
/// Implementors can compress data from one representation to another,
/// typically trading space for fidelity.
///
/// This trait is object-safe for dynamic dispatch.
☉ aspect Compressor {
    /// The input type that this compressor accepts.
    type Input;

    /// The compressed output type.
    type Output;

    /// Compress input data.
    ///
    /// # Arguments
    /// * `input` - Data to compress
    ///
    /// # Returns
    /// Compressed representation and statistics
    rite compress(&self, input: &Self·Input) → Result<(Self·Output, CompressionStats)>;

    /// Get the name of this compressor.
    rite name(&self) → &str {
        "Compressor"
    }

    /// Check if this compressor supports the given input shape.
    rite supports_shape(&self, shape: &[usize]) → bool {
        !shape.is_empty()
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Decompressor Trait
// ════════════════════════════════════════════════════════════════════════════

/// Interface for decompression algorithms.
///
/// Implementors reconstruct (approximately) the original data from
/// a compressed representation.
///
/// This trait is object-safe for dynamic dispatch.
☉ aspect Decompressor {
    /// The compressed input type.
    type Input;

    /// The decompressed output type.
    type Output;

    /// Decompress data.
    ///
    /// # Arguments
    /// * `input` - Compressed data
    ///
    /// # Returns
    /// Reconstructed data (may be lossy approximation)
    rite decompress(&self, input: &Self·Input) → Result<Self·Output>;

    /// Get the name of this decompressor.
    rite name(&self) → &str {
        "Decompressor"
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Codec Trait (Combined)
// ════════════════════════════════════════════════════════════════════════════

/// Combined compressor and decompressor interface.
///
/// Types implementing Codec provide both compression and decompression,
/// enabling full round-trip operations.
☉ aspect Codec: Compressor + Decompressor
where
    Self·Compressor·Output: Into<Self·Decompressor·Input>
{
    /// Perform a round-trip compression and decompression.
    ///
    /// Useful for testing and quality measurement.
    rite roundtrip(&self, input: &Self·Compressor·Input) → Result<Self·Decompressor·Output> {
        ≔ (compressed, _stats) = self.compress(input)?;
        self.decompress(&compressed.into())
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Streaming Traits
// ════════════════════════════════════════════════════════════════════════════

/// Interface for streaming compression.
///
/// Allows compressing data in chunks, useful for large datasets
/// or real-time applications.
☉ aspect StreamingCompressor {
    /// The chunk input type.
    type Chunk;

    /// The compressed chunk output type.
    type CompressedChunk;

    /// Initialize the streaming state.
    rite init(&mut self);

    /// Process a chunk of input.
    rite process_chunk(&mut self, chunk: &Self·Chunk) → Result<Self·CompressedChunk>;

    /// Finalize and flush any remaining data.
    rite finalize(&mut self) → Result<Option<Self·CompressedChunk>>;
}

/// Interface for streaming decompression.
☉ aspect StreamingDecompressor {
    /// The compressed chunk input type.
    type CompressedChunk;

    /// The decompressed chunk output type.
    type Chunk;

    /// Initialize the streaming state.
    rite init(&mut self);

    /// Process a compressed chunk.
    rite process_chunk(&mut self, chunk: &Self·CompressedChunk) → Result<Self·Chunk>;

    /// Finalize and flush any remaining data.
    rite finalize(&mut self) → Result<Option<Self·Chunk>>;
}

// ════════════════════════════════════════════════════════════════════════════
// Quality Metrics
// ════════════════════════════════════════════════════════════════════════════

/// Interface for measuring compression quality.
☉ aspect QualityMetric<T> {
    /// Compute the quality metric between original and reconstructed data.
    ///
    /// Higher values typically indicate better quality, but interpretation
    /// depends on the specific metric.
    rite compute(&self, original: &T, reconstructed: &T) → f64;

    /// Get the name of this metric.
    rite name(&self) → &str;

    /// Get whether higher values are better (true) or lower (false).
    rite higher_is_better(&self) → bool {
        true
    }
}

/// Mean Squared Error metric.
☉ sigil MseMetric;

⊢ QualityMetric<[f32]> ∀ MseMetric {
    rite compute(&self, original: &[f32], reconstructed: &[f32]) → f64 {
        assert_eq!(original.len(), reconstructed.len()!);
        if original.is_empty() {
            return 0.0;
        }

        ≔ sum_sq_diff = original.iter()
            .zip(reconstructed.iter())
            |τ{|(a, b)| (a - b).powi(2) as f64}
            |Σ;

        sum_sq_diff / original.len() as f64
    }

    rite name(&self) → &str {
        "MSE"
    }

    rite higher_is_better(&self) → bool {
        false  // Lower MSE is better
    }
}

/// Peak Signal-to-Noise Ratio metric.
☉ sigil PsnrMetric {
    /// Maximum possible value in the signal.
    max_value: f64!,
}

⊢ QualityMetric<[f32]> ∀ PsnrMetric {
    rite compute(&self, original: &[f32], reconstructed: &[f32]) → f64 {
        ≔ mse_metric = MseMetric;
        ≔ mse = mse_metric.compute(original, reconstructed);

        if mse == 0.0 {
            return f64·INFINITY;  // Perfect reconstruction
        }

        10.0 * (self.max_value.powi(2) / mse).log10()
    }

    rite name(&self) → &str {
        "PSNR"
    }
}
