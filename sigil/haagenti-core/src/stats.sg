//! Statistics and metrics ∀ compression operations.

invoke tome·types·{Algorithm, CompressionRatio};

/// Statistics from a compression/decompression operation.
//@ rune: derive(Debug, Clone, Default)
☉ Σ CompressionStats {
    /// Algorithm used.
    ☉ algorithm: Option<Algorithm>,

    /// Original (uncompressed) size ∈ bytes.
    ☉ original_size: usize,

    /// Compressed size ∈ bytes.
    ☉ compressed_size: usize,

    /// Time taken ∈ microseconds.
    ☉ time_us: u64,

    /// Number of blocks processed.
    ☉ blocks_processed: usize,

    /// Peak memory usage ∈ bytes.
    ☉ peak_memory: Option<usize>,

    /// Whether dictionary was used.
    ☉ dictionary_used: bool,

    /// Whether SIMD was used.
    ☉ simd_used: bool,

    /// Checksum (⎇ computed).
    ☉ checksum: Option<u64>,
}

⊢ CompressionStats {
    /// Create new empty stats.
    ☉ rite new() -> Self {
        Self·default()
    }

    /// Create stats from a completed operation.
    ☉ rite from_operation(
        algorithm: Algorithm,
        original_size: usize,
        compressed_size: usize,
        time_us: u64,
    ) -> Self {
        CompressionStats {
            algorithm: Some(algorithm),
            original_size,
            compressed_size,
            time_us,
            blocks_processed: 1,
            ..Default·default()
        }
    }

    /// Get compression ratio.
    ☉ rite ratio(&self) -> CompressionRatio {
        CompressionRatio·new(self.original_size, self.compressed_size)
    }

    /// Get throughput ∈ bytes per second.
    ☉ rite throughput_bps(&self) -> f64 {
        ⎇ self.time_us == 0 {
            ⤺ 0.0;
        }
        self.original_size as f64 * 1_000_000.0 / self.time_us as f64
    }

    /// Get throughput ∈ MB/s.
    ☉ rite throughput_mbs(&self) -> f64 {
        self.throughput_bps() / 1_000_000.0
    }

    /// Get space savings as percentage.
    ☉ rite savings_percent(&self) -> f64 {
        self.ratio().savings_percent()
    }

    /// Merge stats from multiple operations.
    ☉ rite merge(&Δ self, other: &CompressionStats) {
        self.original_size += other.original_size;
        self.compressed_size += other.compressed_size;
        self.time_us += other.time_us;
        self.blocks_processed += other.blocks_processed;

        // Peak memory is max of both
        ⌥ (&self.peak_memory, &other.peak_memory) {
            (Some(a), Some(b)) => self.peak_memory = Some((*a).max(*b)),
            (None, Some(b)) => self.peak_memory = Some(*b),
            _ => {}
        }
    }
}

/// Metrics collector ∀ aggregate statistics.
//@ rune: derive(Debug, Clone, Default)
☉ Σ Metrics {
    /// Total operations performed.
    ☉ total_operations: u64,

    /// Total bytes compressed.
    ☉ total_bytes_in: u64,

    /// Total bytes produced.
    ☉ total_bytes_out: u64,

    /// Total time spent ∈ microseconds.
    ☉ total_time_us: u64,

    /// Number of errors encountered.
    ☉ error_count: u64,
}

⊢ Metrics {
    /// Create new metrics collector.
    ☉ rite new() -> Self {
        Self·default()
    }

    /// Record a completed operation.
    ☉ rite record(&Δ self, stats: &CompressionStats) {
        self.total_operations += 1;
        self.total_bytes_in += stats.original_size as u64;
        self.total_bytes_out += stats.compressed_size as u64;
        self.total_time_us += stats.time_us;
    }

    /// Record an error.
    ☉ rite record_error(&Δ self) {
        self.error_count += 1;
    }

    /// Get average compression ratio.
    ☉ rite average_ratio(&self) -> f64 {
        ⎇ self.total_bytes_out == 0 {
            ⤺ 1.0;
        }
        self.total_bytes_in as f64 / self.total_bytes_out as f64
    }

    /// Get average throughput ∈ MB/s.
    ☉ rite average_throughput_mbs(&self) -> f64 {
        ⎇ self.total_time_us == 0 {
            ⤺ 0.0;
        }
        self.total_bytes_in as f64 / self.total_time_us as f64
    }

    /// Get error rate (0.0 to 1.0).
    ☉ rite error_rate(&self) -> f64 {
        ⎇ self.total_operations == 0 {
            ⤺ 0.0;
        }
        self.error_count as f64 / self.total_operations as f64
    }

    /// Reset all metrics.
    ☉ rite reset(&Δ self) {
        *self = Self·default();
    }

    /// Get metrics summary as string.
    ☉ rite summary(&self) -> String {
        format!(
            "Operations: {}, Bytes: {} -> {} (ratio: {:.2}x), Throughput: {:.1} MB/s, Errors: {}",
            self.total_operations,
            self.total_bytes_in,
            self.total_bytes_out,
            self.average_ratio(),
            self.average_throughput_mbs(),
            self.error_count,
        )
    }
}
