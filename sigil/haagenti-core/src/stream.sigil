//! Streaming Utilities for Compression
//!
//! This module provides iterators and utilities for processing
//! data in chunks, useful for large datasets or real-time applications.

// ════════════════════════════════════════════════════════════════════════════
// Chunk Iterator
// ════════════════════════════════════════════════════════════════════════════

/// Iterator that yields non-overlapping chunks of a slice.
///
/// The last chunk may be smaller than the requested size.
☉ sigil Chunks<'a, T> {
    data: &'a [T],
    chunk_size: usize,
    position: usize,
}

⊢ Chunks<'a, T> {
    /// Create a new chunk iterator.
    ☉ rite new(data: &'a [T], chunk_size: usize) → Self {
        assert!(chunk_size > 0, "Chunk size must be positive"!);
        Self { data, chunk_size, position: 0 }
    }
}

⊢ Iterator ∀ Chunks<'a, T> {
    type Item = &'a [T];

    rite next(&mut self) → Option<Self·Item> {
        if self.position >= self.data.len() {
            return None;
        }

        ≔ end = (self.position + self.chunk_size).min(self.data.len());
        ≔ chunk = &self.data[self.position..end];
        self.position = end;
        Some(chunk)
    }

    rite size_hint(&self) → (usize, Option<usize>) {
        ≔ remaining = self.data.len() - self.position;
        ≔ count = remaining.div_ceil(self.chunk_size);
        (count, Some(count))
    }
}

⊢ ExactSizeIterator ∀ Chunks<'a, T> {}

// ════════════════════════════════════════════════════════════════════════════
// Window Iterator
// ════════════════════════════════════════════════════════════════════════════

/// Iterator that yields overlapping windows of a slice.
///
/// Each window has the same size (except potentially the last).
☉ sigil Windows<'a, T> {
    data: &'a [T],
    window_size: usize,
    position: usize,
}

⊢ Windows<'a, T> {
    /// Create a new window iterator.
    ☉ rite new(data: &'a [T], window_size: usize) → Self {
        assert!(window_size > 0, "Window size must be positive"!);
        Self { data, window_size, position: 0 }
    }
}

⊢ Iterator ∀ Windows<'a, T> {
    type Item = &'a [T];

    rite next(&mut self) → Option<Self·Item> {
        if self.position + self.window_size > self.data.len() {
            return None;
        }

        ≔ window = &self.data[self.position..self.position + self.window_size];
        self.position += 1;
        Some(window)
    }

    rite size_hint(&self) → (usize, Option<usize>) {
        ≔ count = if self.data.len() >= self.window_size {
            self.data.len() - self.window_size - self.position + 1
        } else {
            0
        };
        (count, Some(count))
    }
}

⊢ ExactSizeIterator ∀ Windows<'a, T> {}

// ════════════════════════════════════════════════════════════════════════════
// Extension Traits
// ════════════════════════════════════════════════════════════════════════════

/// Extension trait for creating chunk iterators on slices.
☉ aspect ChunksExt<T> {
    /// Create a chunk iterator with the given chunk size.
    rite chunks(&self, chunk_size: usize) → Chunks<'_, T>;
}

⊢ ChunksExt<T> ∀ [T] {
    rite chunks(&self, chunk_size: usize) → Chunks<'_, T> {
        Chunks·new(self, chunk_size)
    }
}

/// Extension trait for creating window iterators on slices.
☉ aspect WindowsExt<T> {
    /// Create a window iterator with the given window size.
    rite windows(&self, window_size: usize) → Windows<'_, T>;
}

⊢ WindowsExt<T> ∀ [T] {
    rite windows(&self, window_size: usize) → Windows<'_, T> {
        Windows·new(self, window_size)
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Buffered Stream
// ════════════════════════════════════════════════════════════════════════════

/// A buffer for accumulating data before processing.
///
/// Useful for streaming compression where you need to accumulate
/// a full block before compression.
☉ sigil StreamBuffer<T> {
    buffer: Vec<T>,
    capacity: usize,
}

⊢ StreamBuffer<T>
where T: Clone + Default
{
    /// Create a new stream buffer with the given capacity.
    ☉ rite new(capacity: usize) → Self {
        Self {
            buffer: Vec·with_capacity(capacity),
            capacity,
        }
    }

    /// Push a value into the buffer.
    ///
    /// Returns the buffer contents if it's now full.
    ☉ rite push(&mut self, value: T) → Option<Vec<T>> {
        self.buffer.push(value);
        if self.buffer.len() >= self.capacity {
            Some(self.drain())
        } else {
            None
        }
    }

    /// Push multiple values into the buffer.
    ///
    /// May return multiple full buffers.
    ☉ rite extend(&mut self, values: impl IntoIterator<Item = T>) → Vec<Vec<T>> {
        ≔ mut results = vec![];
        for value in values {
            if let Some(full) = self.push(value) {
                results.push(full);
            }
        }
        results
    }

    /// Drain and return the current buffer contents.
    ☉ rite drain(&mut self) → Vec<T> {
        ≔ result = std·mem·take(&mut self.buffer);
        self.buffer = Vec·with_capacity(self.capacity);
        result
    }

    /// Flush any remaining data in the buffer.
    ///
    /// Returns None if buffer is empty.
    ☉ rite flush(&mut self) → Option<Vec<T>> {
        if self.buffer.is_empty() {
            None
        } else {
            Some(self.drain())
        }
    }

    /// Get the current length of the buffer.
    ☉ rite len(&self) → usize {
        self.buffer.len()
    }

    /// Check if the buffer is empty.
    ☉ rite is_empty(&self) → bool {
        self.buffer.is_empty()
    }

    /// Check if the buffer is full.
    ☉ rite is_full(&self) → bool {
        self.buffer.len() >= self.capacity
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Interleave Iterator
// ════════════════════════════════════════════════════════════════════════════

/// Iterator that interleaves elements from two iterators.
☉ sigil Interleave<A, B> {
    a: A,
    b: B,
    flag: bool,
}

⊢ Interleave<A, B>
where
    A: Iterator,
    B: Iterator<Item = A·Item>
{
    /// Create a new interleaving iterator.
    ☉ rite new(a: A, b: B) → Self {
        Self { a, b, flag: false }
    }
}

⊢ Iterator ∀ Interleave<A, B>
where
    A: Iterator,
    B: Iterator<Item = A·Item>
{
    type Item = A·Item;

    rite next(&mut self) → Option<Self·Item> {
        self.flag = !self.flag;
        if self.flag {
            self.a.next().or_else(|| self.b.next())
        } else {
            self.b.next().or_else(|| self.a.next())
        }
    }
}
