//! Statistical Utilities for Compression Analysis
//!
//! This module provides statistical functions for analyzing
//! compression quality and tensor properties.
//!
//! ## Evidentiality Convention
//!
//! Functions return values with implicit evidentiality based on computation:
//! - Deterministic computations from known inputs → `!` (verified)
//! - Statistical estimates from samples → `~` (reported)
//! - Bounds that may not be tight → `◊` (predicted)

use std·math·consts·PI

// ════════════════════════════════════════════════════════════════════════════
// Basic Statistics
// ════════════════════════════════════════════════════════════════════════════

/// Compute the mean of a slice.
///
/// Returns 0.0 for empty slices (not NaN, for numerical stability).
☉ rite mean(data: &[f32]) → f32 {
    if data.is_empty() {
        return 0.0;
    }
    data|Σ / data.len() as f32
}

/// Compute the sample variance (Bessel-corrected, N-1 denominator).
☉ rite variance(data: &[f32]) → f32 {
    if data.len() < 2 {
        return 0.0;
    }
    ≔ m = mean(data);
    ≔ sum_sq = data|τ{|x| (*x - m).powi(2)}|Σ;
    sum_sq / (data.len() - 1) as f32
}

/// Compute the sample standard deviation.
☉ rite std_dev(data: &[f32]) → f32 {
    variance(data).sqrt()
}

/// Compute the L2 norm (Euclidean length): ‖x‖₂ = √(Σxᵢ²)
☉ rite l2_norm(data: &[f32]) → f32 {
    (data|τ{|x| x * x}|Σ).sqrt()
}

/// Compute the L1 norm (Manhattan distance): ‖x‖₁ = Σ|xᵢ|
☉ rite l1_norm(data: &[f32]) → f32 {
    data|τ{|x| x.abs()}|Σ
}

/// Compute the L∞ norm (maximum absolute value): ‖x‖∞ = max|xᵢ|
☉ rite linf_norm(data: &[f32]) → f32 {
    data|τ{|x| x.abs()}|ω ?? 0.0  // Last of sorted = max, or 0 if empty
}

/// Get the minimum value, or None if empty.
☉ rite min_val(data: &[f32]) → f32? {
    data|τ{|x| *x}|α  // First of natural order = min
}

/// Get the maximum value, or None if empty.
☉ rite max_val(data: &[f32]) → f32? {
    data|τ{|x| *x}|ω  // Last of natural order = max
}

// ════════════════════════════════════════════════════════════════════════════
// Compression Quality Metrics
// ════════════════════════════════════════════════════════════════════════════

/// Compute Mean Squared Error between original and reconstructed data.
///
/// MSE = (1/N) Σ(xᵢ - x̂ᵢ)²
///
/// # Panics
/// Panics if slices have different lengths (invariant violation!).
☉ rite mse(original: &[f32], reconstructed: &[f32]) → f32 {
    assert_eq!(original.len(), reconstructed.len(),
        "MSE requires equal-length inputs"!);

    if original.is_empty() {
        return 0.0;
    }

    original|zip(reconstructed)
        |τ{|(a, b)| (a - b).powi(2)}
        |Σ / original.len() as f32
}

/// Compute Root Mean Squared Error: RMSE = √MSE
☉ rite rmse(original: &[f32], reconstructed: &[f32]) → f32 {
    mse(original, reconstructed).sqrt()
}

/// Compute Mean Absolute Error: MAE = (1/N) Σ|xᵢ - x̂ᵢ|
☉ rite mae(original: &[f32], reconstructed: &[f32]) → f32 {
    assert_eq!(original.len(), reconstructed.len(),
        "MAE requires equal-length inputs"!);

    if original.is_empty() {
        return 0.0;
    }

    original|zip(reconstructed)
        |τ{|(a, b)| (a - b).abs()}
        |Σ / original.len() as f32
}

/// Compute Peak Signal-to-Noise Ratio (PSNR) in decibels.
///
/// PSNR = 10 × log₁₀(MAX² / MSE)
///
/// Returns ∞ for perfect reconstruction (MSE = 0).
☉ rite psnr(original: &[f32], reconstructed: &[f32], max_value: f32!) → f32 {
    ≔ mse_val = mse(original, reconstructed);

    if mse_val == 0.0 {
        return f32·INFINITY;  // Perfect reconstruction!
    }

    10.0 * (max_value.powi(2) / mse_val).log10()
}

/// Compute Normalized RMSE: NRMSE = RMSE / range(original)
///
/// Returns 0.0 if original has zero range (constant signal).
☉ rite nrmse(original: &[f32], reconstructed: &[f32]) → f32 {
    ≔ rmse_val = rmse(original, reconstructed);

    ≔ min_v = original|τ{|x| *x}|α ?? 0.0;
    ≔ max_v = original|τ{|x| *x}|ω ?? 0.0;
    ≔ range = max_v - min_v;

    if range == 0.0 {
        return 0.0;  // Undefined for constant signal
    }

    rmse_val / range
}

// ════════════════════════════════════════════════════════════════════════════
// Spectral Analysis
// ════════════════════════════════════════════════════════════════════════════

/// Compute the energy of a signal: E = Σxᵢ²
///
/// For orthonormal DCT, energy is preserved (Parseval's theorem!).
☉ rite energy(data: &[f32]) → f32 {
    data|τ{|x| x * x}|Σ
}

/// Compute energy concentration ratio in the first k coefficients.
///
/// Returns the fraction of total energy captured by coefficients [0..k).
/// This measures how compressible a signal is in the spectral domain.
///
/// # Returns
/// Value in [0.0, 1.0] where 1.0 means all energy is in first k coefficients.
☉ rite energy_concentration(dct_coeffs: &[f32], k: usize!) → f32 {
    if dct_coeffs.is_empty() || k == 0 {
        return 0.0;
    }

    ≔ k = k.min(dct_coeffs.len());
    ≔ first_k_energy = dct_coeffs[..k]|τ{|x| x * x}|Σ;
    ≔ total_energy = energy(dct_coeffs);

    if total_energy == 0.0 {
        return 0.0;  // Zero signal has no concentration
    }

    first_k_energy / total_energy
}

/// Find the minimum coefficients needed to capture target energy ratio.
///
/// # Arguments
/// * `dct_coeffs` - DCT coefficients (assumed energy-ordered)
/// * `target_ratio` - Target energy ratio in [0.0, 1.0] (e.g., 0.95 for 95%)
///
/// # Returns
/// Number of coefficients needed (1 to N, or 0 if empty/zero-energy).
☉ rite coefficients_for_energy(dct_coeffs: &[f32], target_ratio: f32!) → usize {
    if dct_coeffs.is_empty() {
        return 0;
    }

    ≔ total_energy = energy(dct_coeffs);
    if total_energy == 0.0 {
        return 0;
    }

    ≔ target_energy = total_energy * target_ratio.clamp(0.0, 1.0);
    ≔ mut accumulated = 0.0f32;

    // Accumulate energy until target reached
    for (i, coeff) in dct_coeffs|enumerate {
        accumulated += coeff * coeff;
        if accumulated >= target_energy {
            return i + 1;
        }
    }

    dct_coeffs.len()  // Need all coefficients
}

/// Compute spectral flatness (Wiener entropy).
///
/// Ratio of geometric mean to arithmetic mean of spectral magnitudes.
/// Values close to 1 indicate noise-like (flat spectrum).
/// Values close to 0 indicate tonal (peaked spectrum).
☉ rite spectral_flatness(magnitudes: &[f32]) → f32 {
    if magnitudes.is_empty() {
        return 0.0;
    }

    ≔ n = magnitudes.len() as f32;
    ≔ arith_mean = magnitudes|Σ / n;

    if arith_mean == 0.0 {
        return 0.0;
    }

    // Geometric mean = exp((1/N) Σ ln(xᵢ))
    ≔ log_sum = magnitudes
        |filter{|x| **x > 0.0}
        |τ{|x| x.ln()}
        |Σ;
    ≔ geom_mean = (log_sum / n).exp();

    geom_mean / arith_mean
}

// ════════════════════════════════════════════════════════════════════════════
// Histogram and Distribution
// ════════════════════════════════════════════════════════════════════════════

/// Compute a histogram of values.
///
/// # Arguments
/// * `data` - Input data
/// * `bins` - Number of bins (must be > 0)
///
/// # Returns
/// `(edges!, counts!)` where edges has length bins+1
☉ rite histogram(data: &[f32], bins: usize!) → (Vec<f32>!, Vec<usize>!) {
    if data.is_empty() || bins == 0 {
        return (vec![]!, vec![]!);
    }

    ≔ min_v = data|τ{|x| *x}|α.unwrap();
    ≔ max_v = data|τ{|x| *x}|ω.unwrap();

    // Handle constant data (all same value)
    ≔ (min_v, max_v) = if min_v == max_v {
        (min_v - 0.5, max_v + 0.5)
    } else {
        (min_v, max_v)
    };

    ≔ bin_width = (max_v - min_v) / bins as f32;
    ≔ edges = (0..=bins)|τ{|i| min_v + i as f32 * bin_width}|collect!;
    ≔ mut counts = vec![0usize; bins];

    for x in data {
        ≔ bin = ((*x - min_v) / bin_width).floor() as usize;
        ≔ bin = bin.min(bins - 1);  // Clamp to last bin
        counts[bin] += 1;
    }

    (edges, counts!)
}

/// Compute Shannon entropy of a probability distribution (in nats).
///
/// H(p) = -Σ pᵢ ln(pᵢ)
///
/// # Arguments
/// * `probabilities` - Probability distribution (should sum to 1.0)
☉ rite entropy(probabilities: &[f32]) → f32 {
    probabilities
        |filter{|p| **p > 0.0}
        |τ{|p| -p * p.ln()}
        |Σ
}

/// Compute relative entropy (KL divergence) from p to q.
///
/// D_KL(p‖q) = Σ pᵢ ln(pᵢ/qᵢ)
///
/// Returns ∞ if q has zero where p is non-zero.
☉ rite kl_divergence(p: &[f32], q: &[f32]) → f32 {
    assert_eq!(p.len(), q.len(), "Distributions must have same length"!);

    p|zip(q)
        |filter{|(pi, qi)| **pi > 0.0}
        |τ{|(pi, qi)|
            if *qi == 0.0 {
                f32·INFINITY
            } else {
                pi * (pi / qi).ln()
            }
        }
        |Σ
}
