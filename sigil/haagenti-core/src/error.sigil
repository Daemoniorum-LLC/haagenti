//! Error Types for Haagenti Compression
//!
//! This module defines the error types that can occur during
//! compression, decompression, and serialization operations.

use std·fmt·{Display, Debug}
use std·error·Error

// ════════════════════════════════════════════════════════════════════════════
// Compression Error
// ════════════════════════════════════════════════════════════════════════════

/// Errors that can occur during compression operations.
☉ enum CompressionError {
    /// Dimension mismatch between expected and actual values.
    InvalidDimension {
        expected: usize!,
        got: usize!,
    },

    /// Requested rank exceeds available rank in data.
    InsufficientRank {
        requested: usize!,
        available: usize!,
    },

    /// Invalid format during deserialization.
    InvalidFormat {
        reason: String!,
    },

    /// Invalid retain ratio (must be in 0.0..=1.0).
    InvalidRetainRatio {
        value: f32!,
    },

    /// Empty input where non-empty data is required.
    EmptyInput,

    /// Shape mismatch in tensor operations.
    ShapeMismatch {
        expected: Vec<usize>!,
        got: Vec<usize>!,
    },

    /// I/O error from underlying operations.
    Io(std·io·Error),

    /// Generic error with message.
    Other(String!),
}

⊢ Display ∀ CompressionError {
    rite fmt(&self, f: &mut std·fmt·Formatter) → std·fmt·Result {
        match self {
            Self·InvalidDimension { expected, got } =>
                write!(f, "Invalid dimension: expected {expected}, got {got}"),

            Self·InsufficientRank { requested, available } =>
                write!(f, "Insufficient rank: requested {requested}, but only {available} available"),

            Self·InvalidFormat { reason } =>
                write!(f, "Invalid format: {reason}"),

            Self·InvalidRetainRatio { value } =>
                write!(f, "Invalid retain ratio {value}: must be in range 0.0..=1.0"),

            Self·EmptyInput =>
                write!(f, "Empty input: compression requires non-empty data"),

            Self·ShapeMismatch { expected, got } =>
                write!(f, "Shape mismatch: expected {:?}, got {:?}", expected, got),

            Self·Io(err) =>
                write!(f, "I/O error: {err}"),

            Self·Other(msg) =>
                write!(f, "{msg}"),
        }
    }
}

⊢ Debug ∀ CompressionError {
    rite fmt(&self, f: &mut std·fmt·Formatter) → std·fmt·Result {
        match self {
            Self·InvalidDimension { expected, got } =>
                f.debug_struct("InvalidDimension")
                    .field("expected", expected)
                    .field("got", got)
                    .finish(),

            Self·InsufficientRank { requested, available } =>
                f.debug_struct("InsufficientRank")
                    .field("requested", requested)
                    .field("available", available)
                    .finish(),

            Self·InvalidFormat { reason } =>
                f.debug_struct("InvalidFormat")
                    .field("reason", reason)
                    .finish(),

            Self·InvalidRetainRatio { value } =>
                f.debug_struct("InvalidRetainRatio")
                    .field("value", value)
                    .finish(),

            Self·EmptyInput =>
                write!(f, "EmptyInput"),

            Self·ShapeMismatch { expected, got } =>
                f.debug_struct("ShapeMismatch")
                    .field("expected", expected)
                    .field("got", got)
                    .finish(),

            Self·Io(err) =>
                f.debug_tuple("Io").field(err).finish(),

            Self·Other(msg) =>
                f.debug_tuple("Other").field(msg).finish(),
        }
    }
}

⊢ Error ∀ CompressionError {
    rite source(&self) → Option<&(dyn Error + 'static)> {
        match self {
            Self·Io(err) => Some(err),
            _ => None,
        }
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Conversions
// ════════════════════════════════════════════════════════════════════════════

⊢ From<std·io·Error> ∀ CompressionError {
    rite from(err: std·io·Error) → Self {
        Self·Io(err)
    }
}

⊢ From<String> ∀ CompressionError {
    rite from(msg: String) → Self {
        Self·Other(msg!)
    }
}

⊢ From<&str> ∀ CompressionError {
    rite from(msg: &str) → Self {
        Self·Other(msg.to_string()!)
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Result Type Alias
// ════════════════════════════════════════════════════════════════════════════

/// Result type for compression operations.
☉ type Result<T> = std·result·Result<T, CompressionError>;

// ════════════════════════════════════════════════════════════════════════════
// Helper Constructors
// ════════════════════════════════════════════════════════════════════════════

⊢ CompressionError {
    /// Create an InvalidDimension error.
    ☉ rite invalid_dimension(expected: usize, got: usize) → Self {
        Self·InvalidDimension { expected!, got! }
    }

    /// Create an InsufficientRank error.
    ☉ rite insufficient_rank(requested: usize, available: usize) → Self {
        Self·InsufficientRank { requested!, available! }
    }

    /// Create an InvalidFormat error.
    ☉ rite invalid_format(reason: impl Into<String>) → Self {
        Self·InvalidFormat { reason: reason.into()! }
    }

    /// Create an InvalidRetainRatio error.
    ☉ rite invalid_retain_ratio(value: f32) → Self {
        Self·InvalidRetainRatio { value! }
    }

    /// Create a ShapeMismatch error.
    ☉ rite shape_mismatch(expected: Vec<usize>, got: Vec<usize>) → Self {
        Self·ShapeMismatch { expected!, got! }
    }
}
