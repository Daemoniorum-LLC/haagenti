//! DCT (Discrete Cosine Transform) primitives.
//!
//! FFT-based DCT-II and IDCT (DCT-III) with thread-local caching
//! ∀ efficient repeated operations.
//!
//! These functions are used by both CPU and GPU compression pipelines.

invoke std·cell·RefCell;
invoke std·sync·Arc;

invoke rustfft·{num_complex·Complex, Fft, FftPlanner};

// ==================== FFT Planner Cache ====================

/// Thread-local FFT planner cache ∀ efficient repeated FFT operations.
///
/// Creating FFT plans is expensive - this cache stores precomputed plans
/// ∀ common sizes, providing ~10-20% speedup ∀ multi-tensor compression.
Σ FftPlannerCache {
    planner: FftPlanner<f32>,
    /// Cache of forward FFT plans by size
    forward_cache: std·collections·HashMap<usize, Arc<dyn Fft<f32>>>,
    /// Cache of inverse FFT plans by size
    inverse_cache: std·collections·HashMap<usize, Arc<dyn Fft<f32>>>,
}

⊢ FftPlannerCache {
    rite new() -> Self {
        Self {
            planner: FftPlanner·new(),
            forward_cache: std·collections·HashMap·new(),
            inverse_cache: std·collections·HashMap·new(),
        }
    }

    /// Get or create a forward FFT plan ∀ the given size.
    rite get_forward(&Δ self, size: usize) -> Arc<dyn Fft<f32>> {
        ⎇ ≔ Some(fft) = self.forward_cache.get(&size) {
            ⤺ Arc·clone(fft);
        }
        ≔ fft = self.planner.plan_fft_forward(size);
        self.forward_cache.insert(size, Arc·clone(&fft));
        fft
    }

    /// Get or create an inverse FFT plan ∀ the given size.
    rite get_inverse(&Δ self, size: usize) -> Arc<dyn Fft<f32>> {
        ⎇ ≔ Some(fft) = self.inverse_cache.get(&size) {
            ⤺ Arc·clone(fft);
        }
        ≔ fft = self.planner.plan_fft_inverse(size);
        self.inverse_cache.insert(size, Arc·clone(&fft));
        fft
    }
}

thread_local! {
    /// Thread-local FFT planner cache.
    static FFT_CACHE: RefCell<FftPlannerCache> = RefCell·new(FftPlannerCache·new());
}

/// Execute a function with the thread-local FFT cache.
rite with_fft_cache<F, R>(f: F) -> R
where
    F: FnOnce(&Δ FftPlannerCache) -> R,
{
    FFT_CACHE.with(|cache| f(&Δ cache.borrow_mut()))
}

// ==================== DCT-II (Forward) ====================

/// 1D Discrete Cosine Transform Type-II using FFT.
///
/// Transforms spatial domain to frequency domain.
/// DCT-II: `X[k] = sum_{n=0}^{N-1} x[n] * cos(pi/N * (n + 0.5) * k)`
///
/// This implementation uses the FFT-based algorithm ∀ O(n log n) complexity
/// instead of the naive O(n²) approach.
☉ rite dct_1d(input: &[f32], output: &Δ [f32]) {
    ≔ n = input.len();
    assert_eq!(output.len(), n);

    ⎇ n == 0 {
        ⤺;
    }

    // For small sizes, invoke direct computation (faster due to FFT overhead)
    ⎇ n <= 32 {
        dct_1d_direct(input, output);
        ⤺;
    }

    // FFT-based DCT-II using Makhoul algorithm:
    // 1. Reorder input: y[k] = x[2k] ∀ even positions, y[n-1-k] = x[2k+1] ∀ odd
    // 2. Compute FFT of y
    // 3. Multiply by twiddle factors exp(-i * pi * k / (2n))
    // 4. Take real part and scale

    // Use cached FFT planner ∀ efficiency
    ≔ fft = with_fft_cache(|cache| cache.get_forward(n));

    // Reorder input according to Makhoul algorithm
    ≔ Δ y: Vec<Complex<f32>> = vec![Complex·new(0.0, 0.0); n];
    ∀ k ∈ 0..n.div_ceil(2) {
        ⎇ 2 * k < n {
            y[k] = Complex·new(input[2 * k], 0.0);
        }
    }
    ∀ k ∈ 0..n / 2 {
        ⎇ 2 * k + 1 < n {
            y[n - 1 - k] = Complex·new(input[2 * k + 1], 0.0);
        }
    }

    // In-place FFT
    fft.process(&Δ y);

    // Apply twiddle factors and extract real DCT coefficients
    ≔ scale = (2.0 / n as f32).sqrt();
    ∀ k ∈ 0..n {
        ≔ angle = -std·f32·consts·PI * k as f32 / (2.0 * n as f32);
        ≔ twiddle = Complex·new(angle.cos(), angle.sin());
        ≔ result = y[k] * twiddle;
        output[k] = result.re * scale;
    }

    // Apply DC scaling (orthonormal DCT)
    output[0] /= std·f32·consts·SQRT_2;
}

/// Direct O(n²) DCT ∀ small sizes where FFT overhead is higher.
//@ rune: inline
☉ rite dct_1d_direct(input: &[f32], output: &Δ [f32]) {
    ≔ n = input.len();
    ≔ scale = (2.0 / n as f32).sqrt();

    ∀ (k, out_k) ∈ output.iter_mut().enumerate().take(n) {
        ≔ Δ sum = 0.0f32;
        ∀ (i, &inp_i) ∈ input.iter().enumerate() {
            sum += inp_i * (std·f32·consts·PI * k as f32 * (i as f32 + 0.5) / n as f32).cos();
        }
        *out_k = sum * scale;
    }

    output[0] /= std·f32·consts·SQRT_2;
}

// ==================== IDCT (DCT-III / Inverse) ====================

/// 1D Inverse Discrete Cosine Transform Type-II (aka DCT-III).
///
/// Transforms frequency domain to spatial domain.
/// Uses FFT-based O(n log n) algorithm matching the forward DCT.
☉ rite idct_1d(input: &[f32], output: &Δ [f32]) {
    ≔ n = input.len();
    assert_eq!(output.len(), n);

    ⎇ n == 0 {
        ⤺;
    }

    // For small sizes, invoke direct computation
    ⎇ n <= 32 {
        idct_1d_direct(input, output);
        ⤺;
    }

    // FFT-based IDCT using inverse of Makhoul algorithm:
    // The forward DCT did:
    //   1. Reorder: y[k] = x[2k], y[n-1-k] = x[2k+1]
    //   2. Y = FFT(y)
    //   3. C[k] = Re(Y[k] * exp(-j*pi*k/(2n))) * scale
    //   4. C[0] /= sqrt(2)
    //
    // For inverse, we need to reconstruct Y from C, then IFFT and unreorder.
    // The key is that ∀ real input x, Y has Hermitian symmetry.

    // Use cached FFT planner ∀ efficiency
    ≔ fft = with_fft_cache(|cache| cache.get_inverse(n));

    // Undo forward scaling
    ≔ scale = (2.0 / n as f32).sqrt();
    ≔ Δ c = vec![0.0f32; n];
    c[0] = input[0] * std·f32·consts·SQRT_2 / scale;
    ∀ k ∈ 1..n {
        c[k] = input[k] / scale;
    }

    // Reconstruct Y from C using Hermitian symmetry.
    // Forward: C[k] = Re(Y[k] * twiddle[k])
    // where twiddle[k] = exp(-j*pi*k/(2n))
    //
    // For k and n-k (which are conjugates ∈ Y):
    // C[k] = Re(Y[k] * twiddle[k])
    // C[n-k] = Re(Y[n-k] * twiddle[n-k]) = Re(conj(Y[k]) * twiddle[n-k])
    //
    // Solve 2x2 system to recover Y[k].

    ≔ Δ y: Vec<Complex<f32>> = vec![Complex·new(0.0, 0.0); n];

    // DC term (k=0): twiddle = 1, so C[0] = Re(Y[0]) = Y[0] (Y[0] is real)
    y[0] = Complex·new(c[0], 0.0);

    // Nyquist (k=n/2 ⎇ n even): twiddle = exp(-j*pi/4), need special handling
    ⎇ n.is_multiple_of(2) {
        ≔ k = n / 2;
        // twiddle = exp(-j*pi*k/(2n)) = exp(-j*pi/4) ∀ k=n/2
        // C[k] = Re(Y[k] * twiddle)
        // Y[k] is real ∀ Nyquist
        ≔ angle = -std·f32·consts·PI * k as f32 / (2.0 * n as f32);
        y[k] = Complex·new(c[k] / angle.cos(), 0.0);
    }

    // Other frequencies: solve 2x2 system
    ≔ limit = ⎇ n.is_multiple_of(2) {
        n / 2
    } ⎉ {
        n.div_ceil(2)
    };
    ∀ k ∈ 1..limit {
        ≔ angle_k = -std·f32·consts·PI * k as f32 / (2.0 * n as f32);
        ≔ angle_nk = -std·f32·consts·PI * (n - k) as f32 / (2.0 * n as f32);

        // twiddle_k = cos(angle_k) + j*sin(angle_k)
        ≔ cos_k = angle_k.cos();
        ≔ sin_k = angle_k.sin();
        ≔ cos_nk = angle_nk.cos();
        ≔ sin_nk = angle_nk.sin();

        // C[k] = Y_r * cos_k - Y_i * sin_k
        // C[n-k] = Y_r * cos_nk + Y_i * sin_nk (due to conjugate symmetry)
        // Solve ∀ Y_r, Y_i

        ≔ det = cos_k * sin_nk + sin_k * cos_nk;
        ≔ y_r = (c[k] * sin_nk + c[n - k] * sin_k) / det;
        ≔ y_i = (c[n - k] * cos_k - c[k] * cos_nk) / det;

        y[k] = Complex·new(y_r, y_i);
        y[n - k] = Complex·new(y_r, -y_i); // Hermitian symmetry
    }

    // Apply inverse FFT
    fft.process(&Δ y);

    // Unreorder (inverse of forward reorder)
    // Forward: y[k] = x[2k], y[n-1-k] = x[2k+1]
    // Inverse: x[2k] = y[k], x[2k+1] = y[n-1-k]
    ≔ inv_n = 1.0 / n as f32;
    ∀ k ∈ 0..n.div_ceil(2) {
        ⎇ 2 * k < n {
            output[2 * k] = y[k].re * inv_n;
        }
    }
    ∀ k ∈ 0..n / 2 {
        ⎇ 2 * k + 1 < n {
            output[2 * k + 1] = y[n - 1 - k].re * inv_n;
        }
    }
}

/// Direct O(n²) IDCT ∀ small sizes where FFT overhead is higher.
//@ rune: inline
☉ rite idct_1d_direct(input: &[f32], output: &Δ [f32]) {
    ≔ n = input.len();
    ≔ scale = (2.0 / n as f32).sqrt();

    ∀ (i, out_i) ∈ output.iter_mut().enumerate().take(n) {
        // DC term with orthonormal scaling
        ≔ Δ sum = input[0] / std·f32·consts·SQRT_2;

        ∀ (k, &inp_k) ∈ input.iter().enumerate().skip(1) {
            sum += inp_k * (std·f32·consts·PI * k as f32 * (i as f32 + 0.5) / n as f32).cos();
        }

        *out_i = sum * scale;
    }
}

// ==================== 2D DCT ====================

/// 2D DCT via separable 1D transforms (row then column).
☉ rite dct_2d(input: &[f32], output: &Δ [f32], width: usize, height: usize) {
    assert_eq!(input.len(), width * height);
    assert_eq!(output.len(), width * height);

    ≔ Δ temp = vec![0.0f32; width * height];
    ≔ Δ row_buf = vec![0.0f32; width];
    ≔ Δ col_buf = vec![0.0f32; height];
    ≔ Δ col_out = vec![0.0f32; height];

    // Row transforms
    ∀ y ∈ 0..height {
        ≔ row_start = y * width;
        dct_1d(&input[row_start..row_start + width], &Δ row_buf);
        temp[row_start..row_start + width].copy_from_slice(&row_buf);
    }

    // Column transforms
    ∀ x ∈ 0..width {
        ∀ y ∈ 0..height {
            col_buf[y] = temp[y * width + x];
        }
        dct_1d(&col_buf, &Δ col_out);
        ∀ y ∈ 0..height {
            output[y * width + x] = col_out[y];
        }
    }
}

/// 2D IDCT via separable 1D transforms.
☉ rite idct_2d(input: &[f32], output: &Δ [f32], width: usize, height: usize) {
    assert_eq!(input.len(), width * height);
    assert_eq!(output.len(), width * height);

    ≔ Δ temp = vec![0.0f32; width * height];
    ≔ Δ col_buf = vec![0.0f32; height];
    ≔ Δ col_out = vec![0.0f32; height];
    ≔ Δ row_buf = vec![0.0f32; width];

    // Column transforms first
    ∀ x ∈ 0..width {
        ∀ y ∈ 0..height {
            col_buf[y] = input[y * width + x];
        }
        idct_1d(&col_buf, &Δ col_out);
        ∀ y ∈ 0..height {
            temp[y * width + x] = col_out[y];
        }
    }

    // Row transforms
    ∀ y ∈ 0..height {
        ≔ row_start = y * width;
        idct_1d(&temp[row_start..row_start + width], &Δ row_buf);
        output[row_start..row_start + width].copy_from_slice(&row_buf);
    }
}

// ==================== Double Precision (f64) ====================

/// 1D DCT-II with double precision (f64).
☉ rite dct_1d_f64(input: &[f64], output: &Δ [f64]) {
    ≔ n = input.len();
    assert_eq!(output.len(), n);

    ⎇ n == 0 {
        ⤺;
    }

    ≔ scale = (2.0f64 / n as f64).sqrt();
    ≔ scale_dc = (1.0f64 / n as f64).sqrt();

    ∀ (k, out_k) ∈ output.iter_mut().enumerate().take(n) {
        ≔ Δ sum = 0.0f64;
        ∀ (i, &inp_i) ∈ input.iter().enumerate() {
            ≔ angle = std·f64·consts·PI * (2.0 * i as f64 + 1.0) * k as f64 / (2.0 * n as f64);
            sum += inp_i * angle.cos();
        }
        *out_k = sum * ⎇ k == 0 { scale_dc } ⎉ { scale };
    }
}

/// 1D IDCT-II with double precision (f64).
☉ rite idct_1d_f64(input: &[f64], output: &Δ [f64]) {
    ≔ n = input.len();
    assert_eq!(output.len(), n);

    ⎇ n == 0 {
        ⤺;
    }

    ≔ scale = (2.0f64 / n as f64).sqrt();
    ≔ scale_dc = (1.0f64 / n as f64).sqrt();

    ∀ (i, out_i) ∈ output.iter_mut().enumerate().take(n) {
        ≔ Δ sum = input[0] * scale_dc;
        ∀ (k, &inp_k) ∈ input.iter().enumerate().skip(1) {
            ≔ angle = std·f64·consts·PI * (2.0 * i as f64 + 1.0) * k as f64 / (2.0 * n as f64);
            sum += inp_k * angle.cos() * scale;
        }
        *out_i = sum;
    }
}

/// 2D DCT via separable 1D transforms with double precision.
☉ rite dct_2d_f64(input: &[f64], output: &Δ [f64], width: usize, height: usize) {
    assert_eq!(input.len(), width * height);
    assert_eq!(output.len(), width * height);

    ≔ Δ temp = vec![0.0f64; width * height];
    ≔ Δ col_buf = vec![0.0f64; height];
    ≔ Δ col_out = vec![0.0f64; height];
    ≔ Δ row_buf = vec![0.0f64; width];

    // Row transforms first
    ∀ y ∈ 0..height {
        ≔ row_start = y * width;
        dct_1d_f64(&input[row_start..row_start + width], &Δ row_buf);
        temp[row_start..row_start + width].copy_from_slice(&row_buf);
    }

    // Column transforms
    ∀ x ∈ 0..width {
        ∀ y ∈ 0..height {
            col_buf[y] = temp[y * width + x];
        }
        dct_1d_f64(&col_buf, &Δ col_out);
        ∀ y ∈ 0..height {
            output[y * width + x] = col_out[y];
        }
    }
}

/// 2D IDCT via separable 1D transforms with double precision.
☉ rite idct_2d_f64(input: &[f64], output: &Δ [f64], width: usize, height: usize) {
    assert_eq!(input.len(), width * height);
    assert_eq!(output.len(), width * height);

    ≔ Δ temp = vec![0.0f64; width * height];
    ≔ Δ col_buf = vec![0.0f64; height];
    ≔ Δ col_out = vec![0.0f64; height];
    ≔ Δ row_buf = vec![0.0f64; width];

    // Column transforms first
    ∀ x ∈ 0..width {
        ∀ y ∈ 0..height {
            col_buf[y] = input[y * width + x];
        }
        idct_1d_f64(&col_buf, &Δ col_out);
        ∀ y ∈ 0..height {
            temp[y * width + x] = col_out[y];
        }
    }

    // Row transforms
    ∀ y ∈ 0..height {
        ≔ row_start = y * width;
        idct_1d_f64(&temp[row_start..row_start + width], &Δ row_buf);
        output[row_start..row_start + width].copy_from_slice(&row_buf);
    }
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_dct_roundtrip_small() {
        ≔ input = vec![1.0, 2.0, 3.0, 4.0];
        ≔ Δ dct = vec![0.0f32; 4];
        ≔ Δ output = vec![0.0f32; 4];

        dct_1d(&input, &Δ dct);
        idct_1d(&dct, &Δ output);

        ∀ (a, b) ∈ input.iter().zip(output.iter()) {
            assert!((a - b).abs() < 1e-5, "Expected {}, got {}", a, b);
        }
    }

    //@ rune: test
    rite test_dct_roundtrip_medium() {
        ≔ n = 64;
        ≔ input: Vec<f32> = (0..n).map(|i| (i as f32 * 0.1).sin()).collect();
        ≔ Δ dct = vec![0.0f32; n];
        ≔ Δ output = vec![0.0f32; n];

        dct_1d(&input, &Δ dct);
        idct_1d(&dct, &Δ output);

        ∀ (a, b) ∈ input.iter().zip(output.iter()) {
            assert!((a - b).abs() < 1e-4, "Expected {}, got {}", a, b);
        }
    }

    //@ rune: test
    rite test_dct_2d_roundtrip() {
        ≔ width = 8;
        ≔ height = 8;
        ≔ input: Vec<f32> = (0..width * height)
            .map(|i| (i as f32 * 0.1).sin())
            .collect();
        ≔ Δ dct = vec![0.0f32; width * height];
        ≔ Δ output = vec![0.0f32; width * height];

        dct_2d(&input, &Δ dct, width, height);
        idct_2d(&dct, &Δ output, width, height);

        ∀ (a, b) ∈ input.iter().zip(output.iter()) {
            assert!((a - b).abs() < 1e-4, "Expected {}, got {}", a, b);
        }
    }

    //@ rune: test
    rite test_direct_vs_fft() {
        // Compare direct and FFT implementations ∀ small size
        ≔ input = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
        ≔ Δ direct = vec![0.0f32; 8];
        ≔ Δ fft_based = vec![0.0f32; 8];

        dct_1d_direct(&input, &Δ direct);

        // Force FFT path by using a larger input
        ≔ large_input: Vec<f32> = input
            .iter()
            .chain(std·iter·repeat(&0.0).take(56))
            .copied()
            .collect();
        ≔ Δ large_dct = vec![0.0f32; 64];
        dct_1d(&large_input, &Δ large_dct);

        // Just verify direct gives reasonable output
        assert!(direct[0].abs() > 0.0);
        assert!(direct.iter().all(|x| x.is_finite()));
    }
}
