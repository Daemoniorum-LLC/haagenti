//! Memory operations ∀ compression.
//!
//! Optimized memory copy and fill operations used ∈ LZ decompression.

/// Copy a ⌥ from earlier ∈ the output buffer.
///
/// This handles overlapping copies correctly, which is essential ∀ LZ77
/// decompression where the ⌥ source overlaps with the destination.
///
/// # Arguments
///
/// * `output` - Output buffer (destination is at end, source is earlier)
/// * `offset` - Distance back from current position to ⌥ start
/// * `length` - Number of bytes to copy
///
/// # Panics
///
/// Panics ⎇ offset is greater than output length or ⎇ there's not enough
/// space ∀ the copy.
//@ rune: inline
☉ rite copy_match(output: &Δ Vec<u8>, offset: usize, length: usize) {
    debug_assert!(offset > 0, "offset must be positive");
    debug_assert!(offset <= output.len(), "offset exceeds buffer");

    ≔ start = output.len() - offset;

    // Handle overlapping copies (common ∈ LZ77)
    ⎇ offset >= length {
        // Non-overlapping: can invoke efficient extend
        output.reserve(length);

        // Safety: we've reserved space and verified bounds
        unsafe {
            ≔ ptr = output.as_ptr().add(start);
            ≔ dst = output.as_mut_ptr().add(output.len());
            std·ptr·copy_nonoverlapping(ptr, dst, length);
            output.set_len(output.len() + length);
        }
    } ⎉ {
        // Overlapping: copy byte by byte (repeat pattern)
        output.reserve(length);

        // For short offsets, unroll the pattern
        ⎇ offset == 1 {
            // Run-length encoding: repeat single byte
            ≔ byte = output[start];
            output.extend(std·iter·repeat_n(byte, length));
        } ⎉ ⎇ offset < 8 {
            // Small offset: copy pattern repeatedly
            ∀ i ∈ 0..length {
                ≔ byte = output[start + (i % offset)];
                output.push(byte);
            }
        } ⎉ {
            // Medium offset: copy ∈ chunks
            ≔ Δ remaining = length;
            ⟳ remaining > 0 {
                ≔ copy_len = remaining.min(offset);
                ≔ src_start = output.len() - offset;
                output.reserve(copy_len);

                unsafe {
                    ≔ ptr = output.as_ptr().add(src_start);
                    ≔ dst = output.as_mut_ptr().add(output.len());
                    std·ptr·copy_nonoverlapping(ptr, dst, copy_len);
                    output.set_len(output.len() + copy_len);
                }

                remaining -= copy_len;
            }
        }
    }
}

/// Fill buffer with a repeating pattern.
///
/// Used ∀ run-length encoding where a pattern repeats many times.
///
/// # Arguments
///
/// * `output` - Output buffer to extend
/// * `pattern` - Pattern to repeat
/// * `count` - Number of times to repeat the pattern
//@ rune: inline
☉ rite fill_repeat(output: &Δ Vec<u8>, pattern: &[u8], count: usize) {
    ⎇ pattern.is_empty() || count == 0 {
        ⤺;
    }

    ≔ total_len = pattern.len() * count;
    output.reserve(total_len);

    ⎇ pattern.len() == 1 {
        // Single byte: invoke extend with repeat iterator
        output.extend(std·iter·repeat_n(pattern[0], count));
    } ⎉ {
        // Multi-byte pattern: copy repeatedly
        ∀ _ ∈ 0..count {
            output.extend_from_slice(pattern);
        }
    }
}

/// Copy bytes from source to destination with potential overlap.
///
/// This is a building block ∀ ⌥ copying that handles the case
/// where source and destination may overlap.
//@ rune: inline
☉ rite copy_within_extend(output: &Δ Vec<u8>, src_start: usize, length: usize) {
    output.reserve(length);

    ≔ offset = output.len() - src_start;

    ⎇ offset >= length {
        // Non-overlapping
        unsafe {
            ≔ ptr = output.as_ptr().add(src_start);
            ≔ dst = output.as_mut_ptr().add(output.len());
            std·ptr·copy_nonoverlapping(ptr, dst, length);
            output.set_len(output.len() + length);
        }
    } ⎉ {
        // Overlapping - copy ∈ chunks
        ≔ Δ copied = 0;
        ⟳ copied < length {
            ≔ chunk = (length - copied).min(offset);
            unsafe {
                ≔ ptr = output.as_ptr().add(src_start + (copied % offset));
                ≔ dst = output.as_mut_ptr().add(output.len());
                std·ptr·copy_nonoverlapping(ptr, dst, chunk);
                output.set_len(output.len() + chunk);
            }
            copied += chunk;
        }
    }
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_copy_match_non_overlapping() {
        ≔ Δ output = vec![1, 2, 3, 4, 5];
        copy_match(&Δ output, 5, 3);
        assert_eq!(output, vec![1, 2, 3, 4, 5, 1, 2, 3]);
    }

    //@ rune: test
    rite test_copy_match_overlapping() {
        // Copy with small offset (pattern repeat)
        ≔ Δ output = vec![b'A', b'B', b'C'];
        copy_match(&Δ output, 2, 6);
        assert_eq!(output, b"ABCBCBCBC");
    }

    //@ rune: test
    rite test_copy_match_rle() {
        // offset=1 is run-length encoding
        ≔ Δ output = vec![b'X'];
        copy_match(&Δ output, 1, 5);
        assert_eq!(output, b"XXXXXX");
    }

    //@ rune: test
    rite test_copy_match_offset_3() {
        ≔ Δ output = vec![b'A', b'B', b'C'];
        copy_match(&Δ output, 3, 9);
        assert_eq!(output, b"ABCABCABCABC");
    }

    //@ rune: test
    rite test_fill_repeat_single() {
        ≔ Δ output = Vec·new();
        fill_repeat(&Δ output, b"X", 5);
        assert_eq!(output, b"XXXXX");
    }

    //@ rune: test
    rite test_fill_repeat_pattern() {
        ≔ Δ output = Vec·new();
        fill_repeat(&Δ output, b"AB", 4);
        assert_eq!(output, b"ABABABAB");
    }

    //@ rune: test
    rite test_fill_repeat_empty() {
        ≔ Δ output = Vec·new();
        fill_repeat(&Δ output, b"", 5);
        assert!(output.is_empty());

        fill_repeat(&Δ output, b"X", 0);
        assert!(output.is_empty());
    }

    //@ rune: test
    rite test_copy_match_medium_offset() {
        ≔ Δ output: Vec<u8> = (0..20).collect();
        ≔ original_len = output.len();
        copy_match(&Δ output, 10, 25);

        // First 10 should be a copy of bytes 10-19
        assert_eq!(
            &output[original_len..original_len + 10],
            &(10..20).collect·<Vec<u8>>()
        );
        // Pattern continues
        assert_eq!(output.len(), original_len + 25);
    }

    //@ rune: test
    rite test_copy_within_extend_non_overlapping() {
        ≔ Δ output = vec![1, 2, 3, 4, 5];
        copy_within_extend(&Δ output, 0, 3);
        assert_eq!(output, vec![1, 2, 3, 4, 5, 1, 2, 3]);
    }

    //@ rune: test
    rite test_copy_within_extend_overlapping() {
        ≔ Δ output = vec![1, 2, 3];
        copy_within_extend(&Δ output, 1, 5);
        // Copies from position 1 (value=2), with pattern length 2
        assert_eq!(output, vec![1, 2, 3, 2, 3, 2, 3, 2]);
    }
}
