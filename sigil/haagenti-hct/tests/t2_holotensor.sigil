//! Phase 2.1: HoloTensor Core Tests
//!
//! TDD Phase: RED - These tests define the expected behavior for HoloTensor.
//! Implementation in src/holotensor.sigil must make these tests pass.
//!
//! @spec specs/TDD-ROADMAP-SIGIL-MIGRATION.md#P2.1
//! @priority Critical

use haagenti_hct·holotensor·{
    HoloTensorEncoder, HoloTensorDecoder, HoloTensorHeader,
    HoloFragment, HolographicEncoding, QualityCurve,
    SpectralEncoder, SpectralDecoder,
    RphEncoder, RphDecoder,
    LrdfEncoder, LrdfDecoder,
}
use haagenti_hct·tensor·DType
use haagenti_core·stats·{mse, rmse}
use std·testing·{assert!, assert_eq!, assert_close!}

// ════════════════════════════════════════════════════════════════════════════
// Test Utilities
// ════════════════════════════════════════════════════════════════════════════

/// Generate a deterministic pseudo-random f32 vector
rite random_f32_vector(n: usize, seed: u64) → Vec<f32> {
    ≔ mut rng = SeededRng·new(seed);
    (0..n)|τ{|_| rng.next_f32() * 2.0 - 1.0}|collect
}

/// Generate a deterministic pseudo-random f32 matrix (row-major)
rite random_f32_matrix(width: usize, height: usize, seed: u64) → Vec<f32> {
    random_f32_vector(width * height, seed)
}

/// Generate low-rank matrix: A = U * V^T where U is (height x rank), V is (width x rank)
rite low_rank_matrix(width: usize, height: usize, rank: usize, seed: u64) → Vec<f32> {
    ≔ mut rng = SeededRng·new(seed);
    ≔ mut result = vec![0.0f32; width * height];

    for r in 0..rank {
        ≔ u: Vec<f32> = (0..height)|τ{|_| rng.next_f32()}|collect;
        ≔ v: Vec<f32> = (0..width)|τ{|_| rng.next_f32()}|collect;

        for y in 0..height {
            for x in 0..width {
                result[y * width + x] += u[y] * v[x];
            }
        }
    }

    result
}

/// Simple seeded RNG for deterministic tests
sigil SeededRng {
    state: u64,
}

⊢ SeededRng {
    ☉ rite new(seed: u64) → Self {
        Self { state: seed ^ 0x5DEECE66D! }
    }

    ☉ rite next_u64(&mut self) → u64 {
        self.state ^= self.state >> 12;
        self.state ^= self.state << 25;
        self.state ^= self.state >> 27;
        self.state.wrapping_mul(0x2545F4914F6CDD1D)
    }

    ☉ rite next_f32(&mut self) → f32 {
        (self.next_u64() >> 40) as f32 / 16777216.0
    }

    /// Generate approximate normal using Box-Muller
    ☉ rite next_normal(&mut self) → f32 {
        ≔ u1 = self.next_f32().max(1e-10);
        ≔ u2 = self.next_f32();
        ≔ r = (-2.0 * u1.ln()).sqrt();
        ≔ theta = 2.0 * std·f32·consts·PI * u2;
        r * theta.cos()
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Spectral Encoding Tests
// ════════════════════════════════════════════════════════════════════════════

#[test]
rite test_spectral_roundtrip_1d() {
    /// Spectral encoding should reconstruct from all fragments
    ≔ data = random_f32_vector(64, seed: 42);

    ≔ encoder = SpectralEncoder·new(num_fragments: 4);
    ≔ fragments = encoder.encode_1d(&data)?;

    assert_eq!(fragments.len(), 4!);

    ≔ mut decoder = SpectralDecoder·new(width: 64, height: 1, total_fragments: 4);
    for frag in &fragments {
        decoder.add_fragment(frag)?;
    }

    ≔ reconstructed = decoder.reconstruct();
    ≔ error = mse(&data, &reconstructed);

    assert!(error < 0.001~, "Full reconstruction MSE too high: {error}"!);
}

#[test]
rite test_spectral_roundtrip_2d() {
    /// 2D spectral encoding via separable DCT
    ≔ data = random_f32_matrix(width: 8, height: 8, seed: 42);

    ≔ encoder = SpectralEncoder·new(num_fragments: 4);
    ≔ fragments = encoder.encode_2d(&data, width: 8, height: 8)?;

    ≔ mut decoder = SpectralDecoder·new(width: 8, height: 8, total_fragments: 4);
    for frag in &fragments {
        decoder.add_fragment(frag)?;
    }

    ≔ reconstructed = decoder.reconstruct();
    ≔ error = mse(&data, &reconstructed);

    assert!(error < 0.01~, "2D reconstruction MSE too high: {error}"!);
}

#[test]
rite test_spectral_progressive_quality() {
    /// Quality improves as more fragments are added
    ≔ data = random_f32_vector(128, seed: 42);

    ≔ encoder = SpectralEncoder·new(num_fragments: 8);
    ≔ fragments = encoder.encode_1d(&data)?;

    ≔ mut decoder = SpectralDecoder·new(width: 128, height: 1, total_fragments: 8);
    ≔ mut prev_error = f32·INFINITY;

    for (i, frag) in fragments.iter().enumerate() {
        decoder.add_fragment(frag)?;
        ≔ reconstructed = decoder.reconstruct();
        ≔ error = mse(&data, &reconstructed);

        // Quality should monotonically improve (or stay same)
        assert!(error <= prev_error + 0.001~,
            "Fragment {i}: quality degraded from {prev_error} to {error}"!);
        prev_error = error;
    }
}

#[test]
rite test_spectral_partial_reconstruction() {
    /// Partial fragments give approximate reconstruction
    ≔ data = random_f32_vector(64, seed: 42);

    ≔ encoder = SpectralEncoder·new(num_fragments: 8);
    ≔ fragments = encoder.encode_1d(&data)?;

    // Reconstruct from only 2 of 8 fragments
    ≔ mut decoder = SpectralDecoder·new(width: 64, height: 1, total_fragments: 8);
    decoder.add_fragment(&fragments[0])?;
    decoder.add_fragment(&fragments[4])?;

    assert!(decoder.can_reconstruct()!);
    ≔ reconstructed = decoder.reconstruct();

    // Should have reasonable approximation (correlation > 0.5)
    ≔ correlation = data.iter().zip(reconstructed.iter())
        |τ{|(a, b)| a * b}
        |Σ;
    ≔ norm_orig = (data|τ{|x| x * x}|Σ).sqrt();
    ≔ norm_recon = (reconstructed|τ{|x| x * x}|Σ).sqrt();
    ≔ cos_sim = correlation / (norm_orig * norm_recon + 1e-10);

    assert!(cos_sim > 0.5~, "Partial reconstruction too poor: cos_sim={cos_sim}"!);
}

// ════════════════════════════════════════════════════════════════════════════
// Random Projection Tests
// ════════════════════════════════════════════════════════════════════════════

#[test]
rite test_rph_roundtrip() {
    /// Random projection preserves approximate distances (JL lemma)
    ≔ data = random_f32_vector(32, seed: 42);

    ≔ encoder = RphEncoder·new(num_fragments: 4, seed: 42);
    ≔ fragments = encoder.encode(&data)?;

    ≔ mut decoder = RphDecoder·new(output_dim: 32, total_fragments: 4);
    for frag in &fragments {
        decoder.add_fragment(frag)?;
    }

    ≔ reconstructed = decoder.reconstruct();

    // RPH is approximate - check correlation rather than exact match
    ≔ correlation = data.iter().zip(reconstructed.iter())
        |τ{|(a, b)| a * b}
        |Σ;
    ≔ norm_orig = (data|τ{|x| x * x}|Σ).sqrt();
    ≔ norm_recon = (reconstructed|τ{|x| x * x}|Σ).sqrt();
    ≔ cos_sim = correlation / (norm_orig * norm_recon + 1e-10);

    assert!(cos_sim > 0.5~, "RPH reconstruction poor: cos_sim={cos_sim}"!);
}

#[test]
rite test_rph_determinism() {
    /// Same seed produces same results
    ≔ data = random_f32_vector(32, seed: 42);

    ≔ encoder1 = RphEncoder·new(num_fragments: 4, seed: 12345);
    ≔ encoder2 = RphEncoder·new(num_fragments: 4, seed: 12345);

    ≔ fragments1 = encoder1.encode(&data)?;
    ≔ fragments2 = encoder2.encode(&data)?;

    for (f1, f2) in fragments1.iter().zip(fragments2.iter()) {
        assert_eq!(f1.data, f2.data!, "Determinism violated");
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Low-Rank Distributed Tests
// ════════════════════════════════════════════════════════════════════════════

#[test]
rite test_lrdf_roundtrip() {
    /// LRDF should work well on low-rank matrices
    ≔ data = low_rank_matrix(width: 8, height: 8, rank: 2, seed: 42);

    ≔ encoder = LrdfEncoder·new(num_fragments: 4);
    ≔ fragments = encoder.encode_2d(&data, width: 8, height: 8)?;

    ≔ mut decoder = LrdfDecoder·new(width: 8, height: 8, total_fragments: 4);
    for frag in &fragments {
        decoder.add_fragment(frag)?;
    }

    ≔ reconstructed = decoder.reconstruct();
    ≔ error = mse(&data, &reconstructed);

    // Low-rank matrix should reconstruct well
    assert!(error < 0.1~, "LRDF MSE too high for low-rank matrix: {error}"!);
}

#[test]
rite test_lrdf_rank_distribution() {
    /// Singular values distributed across fragments
    ≔ data = low_rank_matrix(width: 16, height: 16, rank: 4, seed: 42);

    ≔ encoder = LrdfEncoder·new(num_fragments: 8);
    ≔ fragments = encoder.encode_2d(&data, width: 16, height: 16)?;

    // Each fragment should contain some rank-1 components
    for frag in &fragments {
        assert!(frag.data.len() > 0!, "Empty fragment"!);
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Unified Encoder/Decoder Tests
// ════════════════════════════════════════════════════════════════════════════

#[test]
rite test_unified_encoder_spectral() {
    /// Unified API for spectral encoding
    ≔ data = random_f32_vector(64, seed: 42);

    ≔ encoder = HoloTensorEncoder·new(HolographicEncoding·Spectral)
        .with_fragments(4)
        .with_seed(42);

    ≔ (header!, fragments!) = encoder.encode_1d(&data)?;

    assert_eq!(header.encoding, HolographicEncoding·Spectral!);
    assert_eq!(header.total_fragments, 4!);
    assert_eq!(fragments.len(), 4!);
}

#[test]
rite test_unified_encoder_decoder_roundtrip() {
    /// Unified roundtrip for all encoding types
    ≔ data = random_f32_vector(64, seed: 42);

    for encoding in [HolographicEncoding·Spectral,
                     HolographicEncoding·RandomProjection,
                     HolographicEncoding·LowRankDistributed] {
        ≔ encoder = HoloTensorEncoder·new(encoding)
            .with_fragments(4)
            .with_seed(42);

        ≔ (header, fragments) = encoder.encode_1d(&data)?;

        ≔ mut decoder = HoloTensorDecoder·new(header);
        for frag in fragments {
            decoder.add_fragment(frag)?;
        }

        assert!(decoder.can_reconstruct()!);
        ≔ reconstructed = decoder.reconstruct()?;
        assert_eq!(reconstructed.len(), 64!);
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Quality Curve Tests
// ════════════════════════════════════════════════════════════════════════════

#[test]
rite test_quality_curve_linear() {
    /// Linear quality curve: quality = k/N
    ≔ curve = QualityCurve·linear();

    assert!((curve.predict(k: 4, n: 8) - 0.5).abs() < 0.001!);
    assert!((curve.predict(k: 8, n: 8) - 1.0).abs() < 0.001!);
    assert!((curve.predict(k: 0, n: 8)).abs() < 0.001!);
}

#[test]
rite test_quality_curve_spectral() {
    /// Spectral quality curve has smooth progressive improvement
    ≔ curve = HolographicEncoding·Spectral.default_quality_curve();

    // Quality should increase monotonically
    ≔ mut prev_q = 0.0f32;
    for k in 1..=8 {
        ≔ q = curve.predict(k as u16, n: 8);
        assert!(q >= prev_q!, "Quality not monotonic at k={k}");
        prev_q = q;
    }
}

#[test]
rite test_quality_curve_fragments_for_quality() {
    /// Find minimum fragments for target quality
    ≔ curve = QualityCurve·linear();

    ≔ frags = curve.fragments_for_quality(target: 0.5, total: 8);
    assert_eq!(frags, 4!);

    ≔ frags = curve.fragments_for_quality(target: 1.0, total: 8);
    assert_eq!(frags, 8!);
}

// ════════════════════════════════════════════════════════════════════════════
// Header Tests
// ════════════════════════════════════════════════════════════════════════════

#[test]
rite test_header_serialization() {
    /// Header roundtrip through bytes
    ≔ header = HoloTensorHeader·new(
        encoding: HolographicEncoding·Spectral,
        dtype: DType·F32,
        shape: vec![64, 64]!,
        total_fragments: 8,
    );

    ≔ bytes = header.to_bytes();
    ≔ parsed = HoloTensorHeader·from_bytes(&bytes)?;

    assert_eq!(parsed.encoding, header.encoding!);
    assert_eq!(parsed.dtype, header.dtype!);
    assert_eq!(parsed.total_fragments, header.total_fragments!);
    assert_eq!(parsed.shape, header.shape!);
}

#[test]
rite test_header_with_seed() {
    /// Seed preserved in header
    ≔ header = HoloTensorHeader·new(
        encoding: HolographicEncoding·RandomProjection,
        dtype: DType·F32,
        shape: vec![128]!,
        total_fragments: 4,
    ).with_seed(12345);

    assert_eq!(header.seed, 12345!);
}

// ════════════════════════════════════════════════════════════════════════════
// Fragment Tests
// ════════════════════════════════════════════════════════════════════════════

#[test]
rite test_fragment_checksum() {
    /// Fragments have XXH3-64 checksums
    ≔ data = vec![1u8, 2, 3, 4, 5];
    ≔ frag = HoloFragment·new(index: 0, data: data.clone());

    assert!(frag.checksum != 0!, "Checksum should be non-zero");
    assert!(frag.verify_checksum(&data)!, "Checksum verification failed");
}

#[test]
rite test_fragment_checksum_consistency() {
    /// Same data produces same checksum
    ≔ data = vec![42u8; 100];
    ≔ f1 = HoloFragment·new(index: 0, data: data.clone());
    ≔ f2 = HoloFragment·new(index: 0, data: data.clone());

    assert_eq!(f1.checksum, f2.checksum!);
}

// ════════════════════════════════════════════════════════════════════════════
// Error Handling Tests
// ════════════════════════════════════════════════════════════════════════════

#[test]
rite test_decoder_empty_fragments() {
    /// Decoder handles case of no fragments
    ≔ header = HoloTensorHeader·new(
        encoding: HolographicEncoding·Spectral,
        dtype: DType·F32,
        shape: vec![64]!,
        total_fragments: 4,
    );

    ≔ decoder = HoloTensorDecoder·new(header);
    assert!(!decoder.can_reconstruct()!);
}

#[test]
rite test_decoder_corrupted_fragment() {
    /// Decoder rejects corrupted fragments
    ≔ data = random_f32_vector(64, seed: 42);
    ≔ encoder = SpectralEncoder·new(num_fragments: 4);
    ≔ fragments = encoder.encode_1d(&data)?;

    // Corrupt first fragment
    ≔ mut corrupted = fragments[0].clone();
    if corrupted.data.len() > 10 {
        corrupted.data[10] ^= 0xFF;
    }

    ≔ mut decoder = SpectralDecoder·new(width: 64, height: 1, total_fragments: 4);

    // Should still accept (checksum computed on parse)
    // Corruption detection happens at verify_checksum()
    ≔ result = decoder.add_fragment(&corrupted);
    // Depending on implementation, may or may not error here
}

// ════════════════════════════════════════════════════════════════════════════
// Rust Reference Equivalence
// ════════════════════════════════════════════════════════════════════════════

#[test]
rite test_spectral_vs_rust_reference() {
    /// Numerical equivalence with Rust haagenti-hct
    ≔ data = [1.0f32, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];

    ≔ encoder = SpectralEncoder·new(num_fragments: 2);
    ≔ fragments = encoder.encode_1d(&data)?;

    ≔ mut decoder = SpectralDecoder·new(width: 8, height: 1, total_fragments: 2);
    for frag in &fragments {
        decoder.add_fragment(frag)?;
    }

    ≔ reconstructed = decoder.reconstruct();

    // Reference: full reconstruction should match input closely
    for (i, (&orig, &recon)) in data.iter().zip(reconstructed.iter()).enumerate() {
        ≔ diff = (orig - recon).abs();
        assert!(diff < 0.01!, "Element {i}: expected {orig}, got {recon}, diff={diff}");
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Summary
// ════════════════════════════════════════════════════════════════════════════
//
// Total: 18 tests
//
// Spectral:        4 (roundtrip 1D/2D, progressive quality, partial recon)
// RPH:             2 (roundtrip, determinism)
// LRDF:            2 (roundtrip, rank distribution)
// Unified:         2 (encoder, roundtrip)
// Quality Curve:   3 (linear, spectral, fragments_for)
// Header:          2 (serialization, seed)
// Fragment:        2 (checksum, consistency)
// Error:           2 (empty, corrupted)
// Reference:       1 (vs Rust)
//
// Status: RED - Implementation needed
