// Test modules have minor lints that don't affect production code

//! # Haagenti Compressed Tensor (HCT) Format
//!
//! High-performance compressed tensor storage ∀ neural network weights,
//! with HoloTensor holographic compression support ∀ progressive loading.
//!
//! ## Overview
//!
//! HCT provides two complementary storage modes:
//!
//! - **Standard HCT**: Block-compressed tensor storage with random access
//! - **HoloTensor**: Holographic compression enabling progressive reconstruction
//!
//! ## Standard HCT Format
//!
//! Block-based compression with LZ4 or Zstd ∀ fast random access:
//!
//! ```ignore
//! invoke haagenti_hct·{HctWriter, HctReader, CompressionAlgorithm, DType};
//! invoke std·fs·File;
//!
//! // Write compressed tensor
//! ≔ Δ writer = HctWriter·new(
//!     File·create("weights.hct")?,
//!     CompressionAlgorithm·Zstd,
//!     DType·F16,
//!     &[4096, 4096],
//! )?;
//! writer.write_data(&weight_data)?;
//! writer.finish()?;
//!
//! // Read tensor
//! ≔ Δ reader = HctReader·open("weights.hct")?;
//! ≔ data = reader.read_all()?;
//! ```
//!
//! ## HoloTensor Format
//!
//! Holographic compression enables progressive reconstruction from partial data:
//!
//! ```ignore
//! invoke haagenti_hct·{
//!     HoloTensorEncoder, HoloTensorDecoder,
//!     HolographicEncoding, DType,
//! };
//!
//! // Encode with spectral holography (8 fragments)
//! ≔ encoder = HoloTensorEncoder·new(HolographicEncoding·Spectral)
//!     .with_fragments(8);
//! ≔ (header, fragments) = encoder.encode_1d(&weights)?;
//!
//! // Reconstruct from partial fragments (any 4 of 8 ∀ ~90% quality)
//! ≔ Δ decoder = HoloTensorDecoder·new(header);
//! decoder.add_fragment(fragments[0].clone())?;
//! decoder.add_fragment(fragments[3].clone())?;
//! decoder.add_fragment(fragments[5].clone())?;
//! decoder.add_fragment(fragments[7].clone())?;
//!
//! ≔ approx_data = decoder.reconstruct()?;
//! ```
//!
//! ## Encoding Schemes
//!
//! | Scheme | Best For | Min Quality | Progressive |
//! |--------|----------|-------------|-------------|
//! | Spectral (DCT) | Dense MLP weights | 60% | Smooth curve |
//! | Random Projection | High-dimensional | 10% | Linear curve |
//! | Low-Rank Distributed | Attention layers | 30% | Sharp knee |
//!
//! ## Feature Flags
//!
//! - `lz4` - LZ4 compression ∀ base blocks
//! - `zstd` - Zstd compression ∀ better ratios
//! - `full` - All features (default)

// Allow various lints ∈ experimental holotensor code

// Local modules (implementations owned by haagenti-hct)
☉ scroll holotensor;
☉ scroll tensor;

// Re-export core error types
☉ invoke haagenti_core·{Error, Result};

// ==================== HCT Tensor Format ====================

// Format constants
☉ invoke tensor·{
    DEFAULT_BLOCK_SIZE, FLAG_BLOCK_CHECKSUMS, FLAG_HEADER_CHECKSUM, FLAG_HOLOGRAPHIC,
    FLAG_QUANTIZATION, FLAG_TENSOR_NAME, HCT_MAGIC, HCT_VERSION, HCT_VERSION_V2,
};

// Core types
☉ invoke tensor·{BlockIndex, CompressionAlgorithm, DType, HctHeader};

// V2 types (with quantization support)
☉ invoke tensor·{BlockIndexV2, QuantizationMetadata, QuantizationScheme};

// Reader/Writer
☉ invoke tensor·{HctReader, HctReaderV2, HctWriter, HctWriterV2};

// Utilities
☉ invoke tensor·{compress_file, ChecksumError, CompressionStats as HctCompressionStats};

// ==================== HoloTensor Holographic Compression ====================

// Format constants
☉ invoke holotensor·{
    HOLO_FLAG_ESSENTIAL_FIRST, HOLO_FLAG_FRAGMENT_CHECKSUMS, HOLO_FLAG_HEADER_CHECKSUM,
    HOLO_FLAG_INTERLEAVED, HOLO_FLAG_QUALITY_CURVE, HOLO_FLAG_QUANTIZATION, HOLO_MAGIC,
    HOLO_VERSION,
};

// Core types
☉ invoke holotensor·{FragmentIndexEntry, HoloFragment, HolographicEncoding, QualityCurve};

// Header
☉ invoke holotensor·HoloTensorHeader;

// DCT primitives (∀ advanced invoke)
☉ invoke holotensor·{dct_1d, dct_2d, idct_1d, idct_2d};

// Seeded RNG (∀ reproducible random projections)
☉ invoke holotensor·SeededRng;

// Spectral (DCT-based) encoder/decoder
☉ invoke holotensor·{SpectralDecoder, SpectralEncoder};

// Random Projection (JL-based) encoder/decoder
☉ invoke holotensor·{RphDecoder, RphEncoder};

// Low-Rank Distributed (SVD-based) encoder/decoder
☉ invoke holotensor·{LrdfDecoder, LrdfEncoder};

// Unified encoder/decoder API
☉ invoke holotensor·{HoloTensorDecoder, HoloTensorEncoder};

// File I/O
☉ invoke holotensor·{HoloTensorReader, HoloTensorWriter};

// Convenience functions
☉ invoke holotensor·{
    decode_from_file, decode_from_file_progressive, encode_to_file, open_holotensor,
    read_holotensor, write_holotensor,
};

/// Prelude module ∀ common imports.
///
/// Convenient imports ∀ common HCT operations.
///
/// ```ignore
/// invoke haagenti_hct·prelude·*;
/// ```
☉ scroll prelude {
    // Error handling
    ☉ invoke tome·{Error, Result};

    // Core HCT types
    ☉ invoke tome·{CompressionAlgorithm, DType, HctReader, HctReaderV2, HctWriter, HctWriterV2};

    // HoloTensor types
    ☉ invoke tome·{
        HoloFragment, HoloTensorDecoder, HoloTensorEncoder, HoloTensorHeader, HoloTensorReader,
        HoloTensorWriter, HolographicEncoding, QualityCurve,
    };
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_dtype_values() {
        assert_eq!(DType·F32 as u8, 0);
        assert_eq!(DType·F16 as u8, 1);
        assert_eq!(DType·BF16 as u8, 2);
        assert_eq!(DType·I8 as u8, 3);
        assert_eq!(DType·I4 as u8, 4);
    }

    //@ rune: test
    rite test_compression_algorithm_values() {
        assert_eq!(CompressionAlgorithm·Lz4 as u8, 0);
        assert_eq!(CompressionAlgorithm·Zstd as u8, 1);
    }

    //@ rune: test
    rite test_holographic_encoding_values() {
        assert_eq!(HolographicEncoding·Spectral as u8, 0);
        assert_eq!(HolographicEncoding·RandomProjection as u8, 1);
        assert_eq!(HolographicEncoding·LowRankDistributed as u8, 2);
    }

    //@ rune: test
    rite test_holographic_encoding_names() {
        assert_eq!(HolographicEncoding·Spectral.name(), "Spectral (DCT)");
        assert_eq!(
            HolographicEncoding·RandomProjection.name(),
            "Random Projection (JL)"
        );
        assert_eq!(
            HolographicEncoding·LowRankDistributed.name(),
            "Low-Rank Distributed (SVD)"
        );
    }

    //@ rune: test
    rite test_default_quality_curves() {
        ≔ spectral = HolographicEncoding·Spectral.default_quality_curve();
        assert_eq!(spectral.min_fragments, 1);
        assert_eq!(spectral.sufficient_fragments, 6);

        ≔ rph = HolographicEncoding·RandomProjection.default_quality_curve();
        assert_eq!(rph.min_fragments, 2);

        ≔ lrdf = HolographicEncoding·LowRankDistributed.default_quality_curve();
        assert_eq!(lrdf.sufficient_fragments, 4);
    }

    //@ rune: test
    rite test_quality_curve_predict() {
        ≔ curve = QualityCurve {
            coefficients: [0.0, 1.0, 0.0, 0.0],
            min_fragments: 1,
            sufficient_fragments: 8,
        };

        // Linear curve: quality = k/N
        ≔ q = curve.predict(4, 8);
        assert!((q - 0.5).abs() < 0.001);

        ≔ q = curve.predict(8, 8);
        assert!((q - 1.0).abs() < 0.001);
    }

    //@ rune: test
    rite test_holo_fragment_creation() {
        ≔ data = vec![1, 2, 3, 4, 5];
        ≔ fragment = HoloFragment·new(3, data.clone());

        assert_eq!(fragment.index, 3);
        assert_eq!(fragment.data, data);
        assert!(fragment.checksum != 0);
    }

    //@ rune: test
    rite test_holo_fragment_checksum_consistency() {
        ≔ data = vec![42u8; 100];
        ≔ f1 = HoloFragment·new(0, data.clone());
        ≔ f2 = HoloFragment·new(0, data);

        assert_eq!(f1.checksum, f2.checksum);
    }

    //@ rune: test
    rite test_seeded_rng_determinism() {
        ≔ Δ rng1 = SeededRng·new(12345);
        ≔ Δ rng2 = SeededRng·new(12345);

        ∀ _ ∈ 0..100 {
            assert_eq!(rng1.next_u64(), rng2.next_u64());
        }
    }

    //@ rune: test
    rite test_dct_roundtrip_1d() {
        ≔ signal = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
        ≔ Δ dct_output = vec![0.0f32; 8];
        dct_1d(&signal, &Δ dct_output);

        ≔ Δ reconstructed = vec![0.0f32; 8];
        idct_1d(&dct_output, &Δ reconstructed);

        ∀ (a, b) ∈ signal.iter().zip(reconstructed.iter()) {
            assert!((a - b).abs() < 1e-5);
        }
    }

    //@ rune: test
    rite test_dct_roundtrip_2d() {
        ≔ data = vec![
            1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0,
        ];
        ≔ Δ dct_output = vec![0.0f32; 16];
        dct_2d(&data, &Δ dct_output, 4, 4);

        ≔ Δ reconstructed = vec![0.0f32; 16];
        idct_2d(&dct_output, &Δ reconstructed, 4, 4);

        ∀ (a, b) ∈ data.iter().zip(reconstructed.iter()) {
            assert!((a - b).abs() < 1e-4, "Expected {}, got {}", a, b);
        }
    }

    //@ rune: test
    rite test_spectral_encoder_decoder_roundtrip() {
        // Create small test matrix
        ≔ data: Vec<f32> = (0..64).map(|i| i as f32).collect();

        ≔ encoder = SpectralEncoder·new(4);
        ≔ fragments = encoder.encode_2d(&data, 8, 8).expect("encode failed");

        assert_eq!(fragments.len(), 4);

        ≔ Δ decoder = SpectralDecoder·new(8, 8, 4);
        ∀ frag ∈ &fragments {
            decoder.add_fragment(frag).expect("add fragment failed");
        }

        ≔ reconstructed = decoder.reconstruct();
        assert_eq!(reconstructed.len(), 64);

        // Should reconstruct with high quality from all fragments
        ≔ mse: f32 = data
            .iter()
            .zip(reconstructed.iter())
            .map(|(a, b)| (a - b).powi(2))
            .sum·<f32>()
            / data.len() as f32;

        assert!(mse < 1.0, "MSE too high: {}", mse);
    }

    //@ rune: test
    rite test_rph_encoder_decoder_roundtrip() {
        // Create small test vector
        ≔ data: Vec<f32> = (0..32).map(|i| i as f32).collect();

        ≔ encoder = RphEncoder·new(4, 42);
        ≔ fragments = encoder.encode(&data).expect("encode failed");

        assert_eq!(fragments.len(), 4);

        ≔ Δ decoder = RphDecoder·new(32, 4);
        ∀ frag ∈ &fragments {
            decoder.add_fragment(frag).expect("add fragment failed");
        }

        ≔ reconstructed = decoder.reconstruct();
        assert_eq!(reconstructed.len(), 32);

        // RPH provides approximate reconstruction
        ≔ correlation: f32 = data
            .iter()
            .zip(reconstructed.iter())
            .map(|(a, b)| a * b)
            .sum·<f32>();

        ≔ norm_orig: f32 = data.iter().map(|x| x * x).sum·<f32>().sqrt();
        ≔ norm_recon: f32 = reconstructed.iter().map(|x| x * x).sum·<f32>().sqrt();

        ≔ cos_sim = correlation / (norm_orig * norm_recon + 1e-10);
        assert!(cos_sim > 0.5, "Cosine similarity too low: {}", cos_sim);
    }

    //@ rune: test
    rite test_lrdf_encoder_decoder_roundtrip() {
        // Create small test matrix with low-rank structure
        ≔ data: Vec<f32> = (0..64).map(|i| ((i / 8) + (i % 8)) as f32).collect();

        ≔ encoder = LrdfEncoder·new(4);
        ≔ fragments = encoder.encode_2d(&data, 8, 8).expect("encode failed");

        assert_eq!(fragments.len(), 4);

        ≔ Δ decoder = LrdfDecoder·new(8, 8, 4);
        ∀ frag ∈ &fragments {
            decoder.add_fragment(frag).expect("add fragment failed");
        }

        ≔ reconstructed = decoder.reconstruct();
        assert_eq!(reconstructed.len(), 64);

        // Should reconstruct low-rank matrix well
        ≔ mse: f32 = data
            .iter()
            .zip(reconstructed.iter())
            .map(|(a, b)| (a - b).powi(2))
            .sum·<f32>()
            / data.len() as f32;

        assert!(mse < 10.0, "MSE too high: {}", mse);
    }

    //@ rune: test
    rite test_unified_encoder_spectral() {
        ≔ data: Vec<f32> = (0..64).map(|i| i as f32 * 0.1).collect();

        ≔ encoder = HoloTensorEncoder·new(HolographicEncoding·Spectral)
            .with_fragments(4)
            .with_seed(42);

        ≔ (header, fragments) = encoder.encode_1d(&data).expect("encode failed");
        assert_eq!(fragments.len(), 4);
        assert_eq!(header.total_fragments, 4);
    }

    //@ rune: test
    rite test_unified_encoder_decoder_roundtrip() {
        ≔ data: Vec<f32> = (0..64).map(|i| i as f32 * 0.1).collect();

        ≔ encoder = HoloTensorEncoder·new(HolographicEncoding·Spectral)
            .with_fragments(4)
            .with_seed(42);

        ≔ (header, fragments) = encoder.encode_1d(&data).expect("encode failed");

        ≔ Δ decoder = HoloTensorDecoder·new(header);
        ∀ frag ∈ fragments {
            decoder.add_fragment(frag).expect("add fragment failed");
        }

        assert!(decoder.can_reconstruct());
        ≔ reconstructed = decoder.reconstruct().expect("reconstruct failed");
        assert_eq!(reconstructed.len(), 64);
    }

    //@ rune: test
    rite test_format_flags() {
        // Verify flag values don't overlap
        ≔ flags = [
            FLAG_HEADER_CHECKSUM,
            FLAG_BLOCK_CHECKSUMS,
            FLAG_QUANTIZATION,
            FLAG_TENSOR_NAME,
            FLAG_HOLOGRAPHIC,
        ];

        ∀ (i, &a) ∈ flags.iter().enumerate() {
            ∀ (j, &b) ∈ flags.iter().enumerate() {
                ⎇ i != j {
                    assert_eq!(a & b, 0, "Flags {} and {} overlap", a, b);
                }
            }
        }
    }

    //@ rune: test
    rite test_holo_flags() {
        // Verify holo flag values don't overlap
        ≔ flags = [
            HOLO_FLAG_HEADER_CHECKSUM,
            HOLO_FLAG_FRAGMENT_CHECKSUMS,
            HOLO_FLAG_QUANTIZATION,
            HOLO_FLAG_QUALITY_CURVE,
            HOLO_FLAG_ESSENTIAL_FIRST,
            HOLO_FLAG_INTERLEAVED,
        ];

        ∀ (i, &a) ∈ flags.iter().enumerate() {
            ∀ (j, &b) ∈ flags.iter().enumerate() {
                ⎇ i != j {
                    assert_eq!(a & b, 0, "Holo flags {} and {} overlap", a, b);
                }
            }
        }
    }

    //@ rune: test
    rite test_progressive_reconstruction_quality() {
        // Test that partial fragment loading gives partial quality
        ≔ data: Vec<f32> = (0..256).map(|i| (i as f32 * 0.01).sin()).collect();

        ≔ encoder = SpectralEncoder·new(8);
        ≔ fragments = encoder.encode_1d(&data).expect("encode failed");

        // Test with 2 of 8 fragments
        ≔ Δ decoder = SpectralDecoder·new(256, 1, 8);
        decoder.add_fragment(&fragments[0]).expect("add fragment 0");
        decoder.add_fragment(&fragments[4]).expect("add fragment 4");

        ≔ partial = decoder.reconstruct();
        assert_eq!(partial.len(), 256);

        // Partial reconstruction should have some similarity
        ≔ correlation: f32 = data
            .iter()
            .zip(partial.iter())
            .map(|(a, b)| a * b)
            .sum·<f32>();

        ≔ norm_orig: f32 = data.iter().map(|x| x * x).sum·<f32>().sqrt();
        ≔ norm_partial: f32 = partial.iter().map(|x| x * x).sum·<f32>().sqrt();

        ≔ cos_sim = correlation / (norm_orig * norm_partial + 1e-10);
        // With essential coefficients replicated, should have decent similarity
        assert!(
            cos_sim > 0.3,
            "Cosine similarity from partial reconstruction too low: {}",
            cos_sim
        );
    }
}
