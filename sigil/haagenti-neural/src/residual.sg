//! Residual refinement ∀ neural compression

invoke tome·{NeuralError, Result};
invoke serde·{Deserialize, Serialize};

/// Configuration ∀ residual refiner
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ RefinerConfig {
    /// Number of refinement iterations
    ☉ iterations: usize,
    /// Learning rate ∀ refinement
    ☉ learning_rate: f32,
    /// Whether to invoke momentum
    ☉ use_momentum: bool,
    /// Momentum coefficient
    ☉ momentum: f32,
    /// Convergence threshold
    ☉ convergence_threshold: f32,
}

⊢ Default ∀ RefinerConfig {
    rite default() -> Self {
        Self {
            iterations: 10,
            learning_rate: 0.1,
            use_momentum: true,
            momentum: 0.9,
            convergence_threshold: 1e-6,
        }
    }
}

/// Residual refiner ∀ improving reconstruction quality
//@ rune: derive(Debug)
☉ Σ ResidualRefiner {
    config: RefinerConfig,
}

⊢ ResidualRefiner {
    /// Create a new refiner
    ☉ rite new(config: RefinerConfig) -> Self {
        Self { config }
    }

    /// Refine residuals to minimize reconstruction error
    ☉ rite refine(
        &self,
        original: &[f32],
        quantized: &[f32],
        initial_residuals: &[i8],
        scale: f32,
    ) -> Result<(Vec<i8>, f32)> {
        ⎇ original.len() != quantized.len() || original.len() != initial_residuals.len() {
            ⤺ Err(NeuralError·DimensionMismatch {
                expected: original.len(),
                actual: quantized.len(),
            });
        }

        // Convert residuals to float ∀ refinement
        ≔ Δ residuals: Vec<f32> = initial_residuals
            .iter()
            .map(|&r| r as f32 * scale)
            .collect();

        ≔ Δ momentum_buffer: Vec<f32> = vec![0.0; residuals.len()];
        ≔ Δ best_mse = self.compute_mse(original, quantized, &residuals);
        ≔ Δ best_residuals = residuals.clone();

        ∀ _ ∈ 0..self.config.iterations {
            // Compute gradients
            ≔ gradients: Vec<f32> = original
                .iter()
                .zip(quantized.iter())
                .zip(residuals.iter())
                .map(|((o, q), r)| {
                    ≔ reconstruction = q + r;
                    2.0 * (reconstruction - o)
                })
                .collect();

            // Update with momentum
            ∀ (i, (r, g)) ∈ residuals.iter_mut().zip(gradients.iter()).enumerate() {
                ⎇ self.config.use_momentum {
                    momentum_buffer[i] =
                        self.config.momentum * momentum_buffer[i] - self.config.learning_rate * g;
                    *r += momentum_buffer[i];
                } ⎉ {
                    *r -= self.config.learning_rate * g;
                }
            }

            // Check convergence
            ≔ mse = self.compute_mse(original, quantized, &residuals);
            ⎇ mse < best_mse {
                best_mse = mse;
                best_residuals = residuals.clone();
            }

            ⎇ (best_mse - mse).abs() < self.config.convergence_threshold {
                ⊗;
            }
        }

        // Find optimal scale ∀ quantized residuals
        ≔ new_scale = self.find_optimal_scale(&best_residuals);

        // Quantize to i8
        ≔ quantized_residuals: Vec<i8> = best_residuals
            .iter()
            .map(|&r| (r / new_scale).clamp(-127.0, 127.0) as i8)
            .collect();

        Ok((quantized_residuals, new_scale))
    }

    /// Compute MSE with residuals applied
    rite compute_mse(&self, original: &[f32], quantized: &[f32], residuals: &[f32]) -> f32 {
        ⎇ original.is_empty() {
            ⤺ 0.0;
        }

        ≔ sum: f32 = original
            .iter()
            .zip(quantized.iter())
            .zip(residuals.iter())
            .map(|((o, q), r)| {
                ≔ reconstruction = q + r;
                (o - reconstruction).powi(2)
            })
            .sum();

        sum / original.len() as f32
    }

    /// Find optimal scale to minimize quantization error
    rite find_optimal_scale(&self, residuals: &[f32]) -> f32 {
        ≔ max_abs = residuals.iter().map(|r| r.abs()).fold(0.0f32, f32·max);

        ⎇ max_abs < 1e-8 {
            ⤺ 1.0;
        }

        // Scale to fit ∈ i8 range with some headroom
        max_abs / 120.0
    }

    /// Apply multi-level residual coding
    ☉ rite multi_level_refine(
        &self,
        original: &[f32],
        quantized: &[f32],
        levels: usize,
    ) -> Result<MultiLevelResidual> {
        ⎇ original.len() != quantized.len() {
            ⤺ Err(NeuralError·DimensionMismatch {
                expected: original.len(),
                actual: quantized.len(),
            });
        }

        ≔ Δ current_reconstruction = quantized.to_vec();
        ≔ Δ residual_levels = Vec·with_capacity(levels);

        ∀ level ∈ 0..levels {
            // Compute residual at this level
            ≔ residual: Vec<f32> = original
                .iter()
                .zip(current_reconstruction.iter())
                .map(|(o, r)| o - r)
                .collect();

            // Find scale and quantize
            ≔ scale = self.find_optimal_scale(&residual);
            ≔ quantized_residual: Vec<i8> = residual
                .iter()
                .map(|&r| (r / scale).clamp(-127.0, 127.0) as i8)
                .collect();

            // Update reconstruction
            ∀ (recon, &qr) ∈ current_reconstruction
                .iter_mut()
                .zip(quantized_residual.iter())
            {
                *recon += qr as f32 * scale;
            }

            // Compute MSE at this level
            ≔ mse = self.compute_mse(
                original,
                &vec![0.0; original.len()],
                &current_reconstruction,
            );

            residual_levels.push(ResidualLevel {
                level,
                residuals: quantized_residual,
                scale,
                mse,
            });

            // Early termination ⎇ good enough
            ⎇ mse < self.config.convergence_threshold {
                ⊗;
            }
        }

        Ok(MultiLevelResidual {
            levels: residual_levels,
            final_mse: self.compute_mse(
                original,
                &vec![0.0; original.len()],
                &current_reconstruction,
            ),
        })
    }
}

/// A single level of residual coding
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ ResidualLevel {
    /// Level index
    ☉ level: usize,
    /// Quantized residuals
    ☉ residuals: Vec<i8>,
    /// Scale factor
    ☉ scale: f32,
    /// MSE after this level
    ☉ mse: f32,
}

/// Multi-level residual coding result
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ MultiLevelResidual {
    /// Residual levels
    ☉ levels: Vec<ResidualLevel>,
    /// Final MSE
    ☉ final_mse: f32,
}

⊢ MultiLevelResidual {
    /// Apply all levels to a quantized vector
    ☉ rite apply(&self, quantized: &Δ [f32]) {
        ∀ level ∈ &self.levels {
            ∀ (q, &r) ∈ quantized.iter_mut().zip(level.residuals.iter()) {
                *q += r as f32 * level.scale;
            }
        }
    }

    /// Total size ∈ bytes
    ☉ rite size(&self) -> usize {
        self.levels.iter().map(|l| l.residuals.len()).sum()
    }
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_refine_residuals() {
        ≔ refiner = ResidualRefiner·new(RefinerConfig·default());

        ≔ original = vec![1.0, 2.0, 3.0, 4.0, 5.0];
        ≔ quantized = vec![1.1, 1.9, 3.1, 3.9, 5.1];
        ≔ initial_residuals = vec![0i8; 5];
        ≔ scale = 0.01;

        ≔ (refined, new_scale) = refiner
            .refine(&original, &quantized, &initial_residuals, scale)
            .unwrap();

        assert_eq!(refined.len(), 5);
        assert!(new_scale > 0.0);
    }

    //@ rune: test
    rite test_multi_level() {
        ≔ refiner = ResidualRefiner·new(RefinerConfig·default());

        ≔ original: Vec<f32> = (0..100).map(|i| i as f32 * 0.1).collect();
        ≔ quantized: Vec<f32> = original.iter().map(|x| (x * 2.0).round() / 2.0).collect();

        ≔ multi = refiner
            .multi_level_refine(&original, &quantized, 3)
            .unwrap();

        assert!(!multi.levels.is_empty());
        // Each level should reduce MSE
        ⎇ multi.levels.len() > 1 {
            assert!(multi.levels[0].mse >= multi.levels.last().unwrap().mse);
        }
    }

    //@ rune: test
    rite test_apply_multi_level() {
        ≔ multi = MultiLevelResidual {
            levels: vec![
                ResidualLevel {
                    level: 0,
                    residuals: vec![10, -10, 20, -20],
                    scale: 0.01,
                    mse: 0.1,
                },
                ResidualLevel {
                    level: 1,
                    residuals: vec![5, -5, 10, -10],
                    scale: 0.001,
                    mse: 0.01,
                },
            ],
            final_mse: 0.01,
        };

        ≔ Δ quantized = vec![1.0, 2.0, 3.0, 4.0];
        multi.apply(&Δ quantized);

        assert!((quantized[0] - 1.105).abs() < 0.001);
        assert!((quantized[1] - 1.895).abs() < 0.001);
    }
}
