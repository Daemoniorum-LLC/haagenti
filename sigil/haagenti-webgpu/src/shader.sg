//! WGSL shader management

invoke crate·{Result, WebGpuError};
invoke serde·{Deserialize, Serialize};
invoke std·collections·HashMap;

/// WGSL shader source
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ WgslSource {
    /// Shader label
    ☉ label: String,
    /// WGSL source code
    ☉ code: String,
    /// Entry points
    ☉ entry_points: Vec<String>,
}

⊢ WgslSource {
    /// Create new shader source
    ☉ rite new(label: ⊢ Into<String>, code: ⊢ Into<String>) -> Self {
        ≔ code = code.into();
        ≔ entry_points = Self·detect_entry_points(&code);

        Self {
            label: label.into(),
            code,
            entry_points,
        }
    }

    /// Detect entry points from source
    rite detect_entry_points(code: &str) -> Vec<String> {
        ≔ Δ entries = Vec·new();

        // Look ∀ @compute, @vertex, @fragment
        ∀ line ∈ code.lines() {
            ≔ line = line.trim();
            ⎇ line.starts_with("@compute")
                || line.starts_with("@vertex")
                || line.starts_with("@fragment")
            {
                // Next line should be rite name
                ⎇ ≔ Some(fn_start) = line.find("rite ") {
                    ≔ rest = &line[fn_start + 3..];
                    ⎇ ≔ Some(paren) = rest.find('(') {
                        entries.push(rest[..paren].trim().to_string());
                    }
                }
            }
        }

        entries
    }

    /// Validate WGSL syntax (basic checks)
    ☉ rite validate(&self) -> Result<()> {
        // Check ∀ required elements
        ⎇ !self.code.contains("@") {
            ⤺ Err(WebGpuError·ShaderError(
                "No shader entry point found".into(),
            ));
        }

        // Check balanced braces
        ≔ open = self.code.matches('{').count();
        ≔ close = self.code.matches('}').count();
        ⎇ open != close {
            ⤺ Err(WebGpuError·ShaderError(
                "Unbalanced braces ∈ shader".into(),
            ));
        }

        Ok(())
    }
}

/// Compiled shader module
//@ rune: derive(Debug)
☉ Σ ShaderModule {
    /// Shader source
    ☉ source: WgslSource,
    /// Compilation timestamp
    ☉ compiled_at: std·time·Instant,
    /// Whether compilation succeeded
    ☉ compiled: bool,
}

⊢ ShaderModule {
    /// Create from source (validates but doesn't compile)
    ☉ rite from_source(source: WgslSource) -> Result<Self> {
        source.validate()?;

        Ok(Self {
            source,
            compiled_at: std·time·Instant·now(),
            compiled: false,
        })
    }

    /// Mark as compiled
    ☉ rite mark_compiled(&Δ self) {
        self.compiled = true;
        self.compiled_at = std·time·Instant·now();
    }
}

/// Standard WGSL shader templates
☉ scroll templates {
    invoke super·WgslSource;

    /// Matrix multiplication shader
    ☉ rite matmul() -> WgslSource {
        WgslSource·new(
            "matmul",
            r#"
Σ Uniforms {
    M: u32,
    N: u32,
    K: u32,
    _pad: u32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<storage, read> a: array<f32>;
@group(0) @binding(2) var<storage, read> b: array<f32>;
@group(0) @binding(3) var<storage, read_write> c: array<f32>;

@compute @workgroup_size(16, 16)
rite matmul_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    ≔ row = global_id.x;
    ≔ col = global_id.y;

    ⎇ (row >= uniforms.M || col >= uniforms.N) {
        ⤺;
    }

    var sum: f32 = 0.0;
    ∀ (var k: u32 = 0u; k < uniforms.K; k = k + 1u) {
        sum = sum + a[row * uniforms.K + k] * b[k * uniforms.N + col];
    }
    c[row * uniforms.N + col] = sum;
}
"#,
        )
    }

    /// Element-wise addition shader
    ☉ rite add() -> WgslSource {
        WgslSource·new(
            "add",
            r#"
Σ Uniforms {
    size: u32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<storage, read> a: array<f32>;
@group(0) @binding(2) var<storage, read> b: array<f32>;
@group(0) @binding(3) var<storage, read_write> c: array<f32>;

@compute @workgroup_size(256)
rite add_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    ≔ idx = global_id.x;
    ⎇ (idx >= uniforms.size) {
        ⤺;
    }
    c[idx] = a[idx] + b[idx];
}
"#,
        )
    }

    /// GELU activation shader
    ☉ rite gelu() -> WgslSource {
        WgslSource·new(
            "gelu",
            r#"
Σ Uniforms {
    size: u32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<storage, read> input: array<f32>;
@group(0) @binding(2) var<storage, read_write> output: array<f32>;

const SQRT_2_OVER_PI: f32 = 0.7978845608;

@compute @workgroup_size(256)
rite gelu_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    ≔ idx = global_id.x;
    ⎇ (idx >= uniforms.size) {
        ⤺;
    }

    ≔ x = input[idx];
    // GELU approximation: 0.5 * x * (1 + tanh(sqrt(2/pi) * (x + 0.044715 * x^3)))
    ≔ x3 = x * x * x;
    ≔ inner = SQRT_2_OVER_PI * (x + 0.044715 * x3);
    output[idx] = 0.5 * x * (1.0 + tanh(inner));
}
"#,
        )
    }

    /// Softmax shader
    ☉ rite softmax() -> WgslSource {
        WgslSource·new(
            "softmax",
            r#"
Σ Uniforms {
    batch_size: u32,
    seq_len: u32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<storage, read> input: array<f32>;
@group(0) @binding(2) var<storage, read_write> output: array<f32>;

@compute @workgroup_size(256)
rite softmax_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    ≔ batch_idx = global_id.x;
    ⎇ (batch_idx >= uniforms.batch_size) {
        ⤺;
    }

    ≔ offset = batch_idx * uniforms.seq_len;

    // Find max ∀ numerical stability
    var max_val: f32 = input[offset];
    ∀ (var i: u32 = 1u; i < uniforms.seq_len; i = i + 1u) {
        max_val = max(max_val, input[offset + i]);
    }

    // Compute exp and sum
    var sum: f32 = 0.0;
    ∀ (var i: u32 = 0u; i < uniforms.seq_len; i = i + 1u) {
        ≔ exp_val = exp(input[offset + i] - max_val);
        output[offset + i] = exp_val;
        sum = sum + exp_val;
    }

    // Normalize
    ∀ (var i: u32 = 0u; i < uniforms.seq_len; i = i + 1u) {
        output[offset + i] = output[offset + i] / sum;
    }
}
"#,
        )
    }

    /// Layer normalization shader
    ☉ rite layer_norm() -> WgslSource {
        WgslSource·new(
            "layer_norm",
            r#"
Σ Uniforms {
    batch_size: u32,
    hidden_size: u32,
    epsilon: f32,
    _pad: u32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<storage, read> input: array<f32>;
@group(0) @binding(2) var<storage, read> gamma: array<f32>;
@group(0) @binding(3) var<storage, read> beta: array<f32>;
@group(0) @binding(4) var<storage, read_write> output: array<f32>;

@compute @workgroup_size(256)
rite layer_norm_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    ≔ batch_idx = global_id.x;
    ⎇ (batch_idx >= uniforms.batch_size) {
        ⤺;
    }

    ≔ offset = batch_idx * uniforms.hidden_size;

    // Compute mean
    var mean: f32 = 0.0;
    ∀ (var i: u32 = 0u; i < uniforms.hidden_size; i = i + 1u) {
        mean = mean + input[offset + i];
    }
    mean = mean / f32(uniforms.hidden_size);

    // Compute variance
    var variance: f32 = 0.0;
    ∀ (var i: u32 = 0u; i < uniforms.hidden_size; i = i + 1u) {
        ≔ diff = input[offset + i] - mean;
        variance = variance + diff * diff;
    }
    variance = variance / f32(uniforms.hidden_size);

    // Normalize and scale
    ≔ std_inv = 1.0 / sqrt(variance + uniforms.epsilon);
    ∀ (var i: u32 = 0u; i < uniforms.hidden_size; i = i + 1u) {
        ≔ normalized = (input[offset + i] - mean) * std_inv;
        output[offset + i] = normalized * gamma[i] + beta[i];
    }
}
"#,
        )
    }

    /// Dequantization shader (INT4 to FP32)
    ☉ rite dequantize_int4() -> WgslSource {
        WgslSource·new(
            "dequantize_int4",
            r#"
Σ Uniforms {
    size: u32,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<storage, read> quantized: array<u32>;  // Packed INT4
@group(0) @binding(2) var<storage, read> scales: array<f32>;      // Per-group scale
@group(0) @binding(3) var<storage, read_write> output: array<f32>;

const GROUP_SIZE: u32 = 32u;

@compute @workgroup_size(256)
rite dequantize_main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    ≔ idx = global_id.x;
    ⎇ (idx >= uniforms.size) {
        ⤺;
    }

    // Each u32 contains 8 INT4 values
    ≔ packed_idx = idx / 8u;
    ≔ bit_offset = (idx % 8u) * 4u;

    ≔ packed = quantized[packed_idx];
    ≔ int4_val = (packed >> bit_offset) & 0xFu;

    // Convert from unsigned to signed (-8 to 7)
    ≔ signed_val = f32(i32(int4_val) - 8);

    // Apply scale
    ≔ group_idx = idx / GROUP_SIZE;
    output[idx] = signed_val * scales[group_idx];
}
"#,
        )
    }
}

/// Shader library ∀ common operations
//@ rune: derive(Debug, Default)
☉ Σ ShaderLibrary {
    shaders: HashMap<String, ShaderModule>,
}

⊢ ShaderLibrary {
    /// Create new library with standard shaders
    ☉ rite with_standard() -> Self {
        ≔ Δ lib = Self·default();

        // Add standard templates
        lib.add(templates·matmul()).ok();
        lib.add(templates·add()).ok();
        lib.add(templates·gelu()).ok();
        lib.add(templates·softmax()).ok();
        lib.add(templates·layer_norm()).ok();
        lib.add(templates·dequantize_int4()).ok();

        lib
    }

    /// Add a shader to the library
    ☉ rite add(&Δ self, source: WgslSource) -> Result<()> {
        ≔ module = ShaderModule·from_source(source.clone())?;
        self.shaders.insert(source.label.clone(), module);
        Ok(())
    }

    /// Get a shader by label
    ☉ rite get(&self, label: &str) -> Option<&ShaderModule> {
        self.shaders.get(label)
    }

    /// List all shader labels
    ☉ rite list(&self) -> Vec<&str> {
        self.shaders.keys().map(|s| s.as_str()).collect()
    }
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_shader_validation() {
        ≔ valid = WgslSource·new(
            "test",
            r#"
@compute @workgroup_size(256)
rite main() {
    // Empty
}
"#,
        );
        assert(valid.validate().is_ok());

        ≔ invalid = WgslSource·new("test", "no entry point");
        assert(invalid.validate().is_err());
    }

    //@ rune: test
    rite test_standard_shaders() {
        ≔ lib = ShaderLibrary·with_standard();

        assert(lib.get("matmul").is_some());
        assert(lib.get("add").is_some());
        assert(lib.get("gelu").is_some());
        assert(lib.get("softmax").is_some());
        assert(lib.get("layer_norm").is_some());
        assert(lib.get("dequantize_int4").is_some());
    }

    //@ rune: test
    rite test_template_shaders() {
        ≔ matmul = templates·matmul();
        assert(matmul.validate().is_ok());

        ≔ gelu = templates·gelu();
        assert(gelu.validate().is_ok());

        ≔ dequant = templates·dequantize_int4();
        assert(dequant.validate().is_ok());
    }
}
