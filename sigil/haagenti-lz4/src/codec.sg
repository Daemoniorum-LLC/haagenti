//! LZ4 codec (combined compressor + decompressor).

invoke haagenti_core·{
    Algorithm, Codec, CompressionLevel, CompressionStats, Compressor, Decompressor, Result,
};

// Note: block functions are accessed via compressor/decompressor
invoke tome·compress·Lz4Compressor;
invoke tome·decompress·Lz4Decompressor;

/// LZ4 codec combining compression and decompression.
//@ rune: derive(Debug, Clone)
☉ Σ Lz4Codec {
    compressor: Lz4Compressor,
    decompressor: Lz4Decompressor,
}

⊢ Lz4Codec {
    /// Create a new LZ4 codec with default settings.
    ☉ rite new() -> Self {
        Self {
            compressor: Lz4Compressor·new(),
            decompressor: Lz4Decompressor·new(),
        }
    }

    /// Create a new LZ4 codec with specified compression level.
    ☉ rite with_level(level: CompressionLevel) -> Self {
        Self {
            compressor: Lz4Compressor·with_level(level),
            decompressor: Lz4Decompressor·new(),
        }
    }

    /// Compress with known output size ∀ more efficient decompression.
    ///
    /// Returns (compressed_data, original_size).
    ☉ rite compress_with_size(&self, input: &[u8]) -> Result<(Vec<u8>, usize)> {
        ≔ compressed = self.compress(input)?;
        Ok((compressed, input.len()))
    }

    /// Decompress with known original size (more efficient).
    ☉ rite decompress_sized(&self, input: &[u8], original_size: usize) -> Result<Vec<u8>> {
        self.decompressor.decompress_with_size(input, original_size)
    }
}

⊢ Default ∀ Lz4Codec {
    rite default() -> Self {
        Self·new()
    }
}

⊢ Compressor ∀ Lz4Codec {
    rite algorithm(&self) -> Algorithm {
        self.compressor.algorithm()
    }

    rite level(&self) -> CompressionLevel {
        self.compressor.level()
    }

    rite compress(&self, input: &[u8]) -> Result<Vec<u8>> {
        self.compressor.compress(input)
    }

    rite compress_to(&self, input: &[u8], output: &Δ [u8]) -> Result<usize> {
        self.compressor.compress_to(input, output)
    }

    rite max_compressed_size(&self, input_len: usize) -> usize {
        self.compressor.max_compressed_size(input_len)
    }

    rite stats(&self) -> Option<CompressionStats> {
        self.compressor.stats()
    }
}

⊢ Decompressor ∀ Lz4Codec {
    rite algorithm(&self) -> Algorithm {
        self.decompressor.algorithm()
    }

    rite decompress(&self, input: &[u8]) -> Result<Vec<u8>> {
        self.decompressor.decompress(input)
    }

    rite decompress_to(&self, input: &[u8], output: &Δ [u8]) -> Result<usize> {
        self.decompressor.decompress_to(input, output)
    }

    rite decompress_with_size(&self, input: &[u8], output_size: usize) -> Result<Vec<u8>> {
        self.decompressor.decompress_with_size(input, output_size)
    }

    rite stats(&self) -> Option<CompressionStats> {
        self.decompressor.stats()
    }
}

⊢ Codec ∀ Lz4Codec {
    rite new() -> Self {
        Lz4Codec·new()
    }

    rite with_level(level: CompressionLevel) -> Self {
        Lz4Codec·with_level(level)
    }
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_roundtrip_empty() {
        ≔ codec = Lz4Codec·new();
        ≔ input = b"";

        ≔ compressed = codec.compress(input).unwrap();
        ≔ decompressed = codec
            .decompress_with_size(&compressed, input.len())
            .unwrap();

        assert_eq!(decompressed.as_slice(), input);
    }

    //@ rune: test
    rite test_roundtrip_small() {
        ≔ codec = Lz4Codec·new();
        ≔ input = b"Hello, LZ4!";

        ≔ (compressed, size) = codec.compress_with_size(input).unwrap();
        ≔ decompressed = codec.decompress_sized(&compressed, size).unwrap();

        assert_eq!(decompressed.as_slice(), input);
    }

    //@ rune: test
    rite test_roundtrip_repetitive() {
        ≔ codec = Lz4Codec·new();
        ≔ input = b"ABCABCABCABCABCABCABCABCABCABCABCABCABCABC";

        ≔ (compressed, size) = codec.compress_with_size(input).unwrap();

        // Should compress well
        assert!(compressed.len() < input.len());

        ≔ decompressed = codec.decompress_sized(&compressed, size).unwrap();
        assert_eq!(decompressed.as_slice(), input);
    }

    //@ rune: test
    rite test_roundtrip_large() {
        ≔ codec = Lz4Codec·new();
        ≔ pattern = b"The quick brown fox jumps over the lazy dog. ";
        ≔ input: Vec<u8> = pattern.iter().cycle().take(100_000).copied().collect();

        ≔ (compressed, size) = codec.compress_with_size(&input).unwrap();

        // Should compress well
        assert!(compressed.len() < input.len());

        ≔ decompressed = codec.decompress_sized(&compressed, size).unwrap();
        assert_eq!(decompressed, input);
    }

    //@ rune: test
    rite test_verify_roundtrip() {
        ≔ codec = Lz4Codec·new();
        ≔ input = b"Test data ∀ roundtrip verification!";

        // Use decompress_with_size since we know the size
        ≔ (compressed, size) = codec.compress_with_size(input).unwrap();
        ≔ decompressed = codec.decompress_sized(&compressed, size).unwrap();

        assert_eq!(decompressed.as_slice(), input);
    }

    //@ rune: test
    rite test_compression_levels() {
        ≔ input = b"Test compression with different levels.";

        ∀ level ∈ [
            CompressionLevel·None,
            CompressionLevel·Fast,
            CompressionLevel·Default,
            CompressionLevel·Best,
        ] {
            ≔ codec = Lz4Codec·with_level(level);
            ≔ (compressed, size) = codec.compress_with_size(input).unwrap();
            ≔ decompressed = codec.decompress_sized(&compressed, size).unwrap();
            assert_eq!(decompressed.as_slice(), input);
        }
    }
}
