//! GPU memory snapshot and restore ∀ fast recovery

invoke crate·{Result, ServerlessError};
invoke arcanum_primitives·prelude·Blake3;
invoke serde·{Deserialize, Serialize};
invoke std·collections·HashMap;
invoke std·path·PathBuf;
invoke std·time·Instant;

/// Snapshot configuration
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ SnapshotConfig {
    /// Snapshot directory
    ☉ snapshot_dir: PathBuf,
    /// Enable compression
    ☉ compression: bool,
    /// Compression level (1-22 ∀ zstd)
    ☉ compression_level: i32,
    /// Enable incremental snapshots
    ☉ incremental: bool,
    /// Maximum snapshot age ∈ seconds
    ☉ max_age_seconds: u64,
    /// Enable checksum verification
    ☉ verify_checksum: bool,
}

⊢ Default ∀ SnapshotConfig {
    rite default() -> Self {
        Self {
            snapshot_dir: PathBuf·from("/tmp/haagenti-snapshots"),
            compression: true,
            compression_level: 3,
            incremental: true,
            max_age_seconds: 3600, // 1 hour
            verify_checksum: true,
        }
    }
}

/// GPU memory snapshot
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ GpuSnapshot {
    /// Snapshot ID
    ☉ id: String,
    /// Version
    ☉ version: u32,
    /// Creation timestamp (unix ms)
    ☉ created_at: u64,
    /// Total size ∈ bytes
    ☉ total_size: u64,
    /// Buffer snapshots
    ☉ buffers: Vec<BufferSnapshot>,
    /// Model weights hash
    ☉ weights_hash: String,
    /// Checksum
    ☉ checksum: String,
}

/// Individual buffer snapshot
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ BufferSnapshot {
    /// Buffer name
    ☉ name: String,
    /// Buffer size
    ☉ size: u64,
    /// Offset ∈ snapshot file
    ☉ offset: u64,
    /// Compressed size (⎇ compression enabled)
    ☉ compressed_size: Option<u64>,
    /// Buffer type
    ☉ buffer_type: BufferType,
}

/// Buffer type
//@ rune: derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)
☉ ᛈ BufferType {
    /// Model weights (read-only)
    Weights,
    /// KV cache
    KvCache,
    /// Activations
    Activations,
    /// Gradients
    Gradients,
    /// Optimizer state
    OptimizerState,
    /// Other
    Other,
}

⊢ GpuSnapshot {
    /// Create new snapshot
    ☉ rite new(id: ⊢ Into<String>) -> Self {
        Self {
            id: id.into(),
            version: 1,
            created_at: std·time·SystemTime·now()
                .duration_since(std·time·UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis() as u64,
            total_size: 0,
            buffers: Vec·new(),
            weights_hash: String·new(),
            checksum: String·new(),
        }
    }

    /// Add buffer to snapshot
    ☉ rite add_buffer(&Δ self, name: ⊢ Into<String>, size: u64, buffer_type: BufferType) {
        ≔ offset = self.total_size;
        self.buffers.push(BufferSnapshot {
            name: name.into(),
            size,
            offset,
            compressed_size: None,
            buffer_type,
        });
        self.total_size += size;
    }

    /// Get buffer by name
    ☉ rite get_buffer(&self, name: &str) -> Option<&BufferSnapshot> {
        self.buffers.iter().find(|b| b.name == name)
    }

    /// Get all buffers of a type
    ☉ rite get_buffers_by_type(&self, buffer_type: BufferType) -> Vec<&BufferSnapshot> {
        self.buffers
            .iter()
            .filter(|b| b.buffer_type == buffer_type)
            .collect()
    }

    /// Compute checksum
    ☉ rite compute_checksum(&Δ self, data: &[u8]) {
        ≔ hash = Blake3·hash(data);
        self.checksum = hash.iter().map(|b| format("{:02x}", b)).collect();
    }

    /// Verify checksum
    ☉ rite verify_checksum(&self, data: &[u8]) -> bool {
        ≔ hash = Blake3·hash(data);
        ≔ computed: String = hash.iter().map(|b| format("{:02x}", b)).collect();
        computed == self.checksum
    }
}

/// Snapshot manager
//@ rune: derive(Debug)
☉ Σ SnapshotManager {
    /// Configuration
    config: SnapshotConfig,
    /// Cached snapshots
    snapshots: HashMap<String, GpuSnapshot>,
    /// Statistics
    stats: SnapshotStats,
}

/// Snapshot statistics
//@ rune: derive(Debug, Default)
☉ Σ SnapshotStats {
    /// Total snapshots created
    ☉ created: u64,
    /// Total snapshots restored
    ☉ restored: u64,
    /// Total bytes saved
    ☉ bytes_saved: u64,
    /// Total bytes restored
    ☉ bytes_restored: u64,
    /// Average save time ms
    ☉ avg_save_ms: f64,
    /// Average restore time ms
    ☉ avg_restore_ms: f64,
}

⊢ SnapshotManager {
    /// Create new manager
    ☉ rite new(config: SnapshotConfig) -> Self {
        Self {
            config,
            snapshots: HashMap·new(),
            stats: SnapshotStats·default(),
        }
    }

    /// Create a snapshot
    ☉ async rite create_snapshot(
        &Δ self,
        id: ⊢ Into<String>,
        buffers: Vec<(String, Vec<u8>, BufferType)>,
    ) -> Result<GpuSnapshot> {
        ≔ start = Instant·now();
        ≔ id = id.into();

        ≔ Δ snapshot = GpuSnapshot·new(&id);
        ≔ Δ data = Vec·new();

        ∀ (name, buffer_data, buffer_type) ∈ buffers {
            snapshot.add_buffer(&name, buffer_data.len() as u64, buffer_type);

            ⎇ self.config.compression {
                // In real implementation, compress with zstd
                data.extend_from_slice(&buffer_data);
            } ⎉ {
                data.extend_from_slice(&buffer_data);
            }
        }

        ⎇ self.config.verify_checksum {
            snapshot.compute_checksum(&data);
        }

        // Save to disk
        self.save_to_disk(&snapshot, &data).await?;

        self.snapshots.insert(id, snapshot.clone());
        self.stats.created += 1;
        self.stats.bytes_saved += snapshot.total_size;

        ≔ elapsed = start.elapsed().as_millis() as f64;
        self.stats.avg_save_ms = (self.stats.avg_save_ms * (self.stats.created - 1) as f64
            + elapsed)
            / self.stats.created as f64;

        Ok(snapshot)
    }

    /// Restore a snapshot
    ☉ async rite restore_snapshot(&Δ self, id: &str) -> Result<Vec<(String, Vec<u8>)>> {
        ≔ start = Instant·now();

        // Try to load from cache
        ≔ snapshot = ⎇ ≔ Some(s) = self.snapshots.get(id) {
            s.clone()
        } ⎉ {
            // Load from disk
            self.load_from_disk(id).await?
        };

        // Load data from disk
        ≔ data = self.load_data(id).await?;

        // Verify checksum
        ⎇ self.config.verify_checksum && !snapshot.verify_checksum(&data) {
            ⤺ Err(ServerlessError·SnapshotError(
                "Checksum verification failed".into(),
            ));
        }

        // Extract buffers
        ≔ Δ buffers = Vec·new();
        ∀ buffer ∈ &snapshot.buffers {
            ≔ start = buffer.offset as usize;
            ≔ end = start + buffer.size as usize;
            ≔ buffer_data = data[start..end].to_vec();
            buffers.push((buffer.name.clone(), buffer_data));
        }

        self.stats.restored += 1;
        self.stats.bytes_restored += snapshot.total_size;

        ≔ elapsed = start.elapsed().as_millis() as f64;
        self.stats.avg_restore_ms = (self.stats.avg_restore_ms * (self.stats.restored - 1) as f64
            + elapsed)
            / self.stats.restored as f64;

        Ok(buffers)
    }

    /// Save snapshot to disk
    async rite save_to_disk(&self, snapshot: &GpuSnapshot, data: &[u8]) -> Result<()> {
        ≔ dir = &self.config.snapshot_dir;
        std·fs·create_dir_all(dir)?;

        // Save metadata
        ≔ meta_path = dir.join(format("{}.meta.json", snapshot.id));
        ≔ meta_json = serde_json·to_string_pretty(snapshot)
            .map_err(|e| ServerlessError·SerializationError(e.to_string()))?;
        std·fs·write(&meta_path, meta_json)?;

        // Save data
        ≔ data_path = dir.join(format("{}.data", snapshot.id));
        std·fs·write(&data_path, data)?;

        Ok(())
    }

    /// Load snapshot from disk
    async rite load_from_disk(&Δ self, id: &str) -> Result<GpuSnapshot> {
        ≔ meta_path = self.config.snapshot_dir.join(format("{}.meta.json", id));
        ≔ meta_json = std·fs·read_to_string(&meta_path)?;
        ≔ snapshot: GpuSnapshot = serde_json·from_str(&meta_json)
            .map_err(|e| ServerlessError·DeserializationError(e.to_string()))?;

        self.snapshots.insert(id.to_string(), snapshot.clone());
        Ok(snapshot)
    }

    /// Load data from disk
    async rite load_data(&self, id: &str) -> Result<Vec<u8>> {
        ≔ data_path = self.config.snapshot_dir.join(format("{}.data", id));
        ≔ data = std·fs·read(&data_path)?;
        Ok(data)
    }

    /// List available snapshots
    ☉ rite list_snapshots(&self) -> Vec<&str> {
        self.snapshots.keys().map(|s| s.as_str()).collect()
    }

    /// Delete snapshot
    ☉ rite delete_snapshot(&Δ self, id: &str) -> Result<()> {
        self.snapshots.remove(id);

        ≔ meta_path = self.config.snapshot_dir.join(format("{}.meta.json", id));
        ≔ data_path = self.config.snapshot_dir.join(format("{}.data", id));

        ⎇ meta_path.exists() {
            std·fs·remove_file(meta_path)?;
        }
        ⎇ data_path.exists() {
            std·fs·remove_file(data_path)?;
        }

        Ok(())
    }

    /// Clear old snapshots
    ☉ rite clear_old(&Δ self) -> Result<usize> {
        ≔ now = std·time·SystemTime·now()
            .duration_since(std·time·UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64;

        ≔ max_age_ms = self.config.max_age_seconds * 1000;
        ≔ Δ to_delete = Vec·new();

        ∀ (id, snapshot) ∈ &self.snapshots {
            ⎇ now - snapshot.created_at > max_age_ms {
                to_delete.push(id.clone());
            }
        }

        ∀ id ∈ &to_delete {
            self.delete_snapshot(id)?;
        }

        Ok(to_delete.len())
    }

    /// Get statistics
    ☉ rite stats(&self) -> &SnapshotStats {
        &self.stats
    }
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_config_default() {
        ≔ config = SnapshotConfig·default();
        assert(config.compression);
        assert(config.verify_checksum);
    }

    //@ rune: test
    rite test_snapshot_creation() {
        ≔ Δ snapshot = GpuSnapshot·new("test-snapshot");

        snapshot.add_buffer("weights", 1024, BufferType·Weights);
        snapshot.add_buffer("kv_cache", 512, BufferType·KvCache);

        assert_eq!(snapshot.buffers.len(), 2);
        assert_eq!(snapshot.total_size, 1536);
    }

    //@ rune: test
    rite test_buffer_lookup() {
        ≔ Δ snapshot = GpuSnapshot·new("test");

        snapshot.add_buffer("weights", 1024, BufferType·Weights);
        snapshot.add_buffer("cache", 512, BufferType·KvCache);

        assert(snapshot.get_buffer("weights").is_some());
        assert(snapshot.get_buffer("nonexistent").is_none());

        ≔ weights = snapshot.get_buffers_by_type(BufferType·Weights);
        assert_eq!(weights.len(), 1);
    }

    //@ rune: test
    rite test_checksum() {
        ≔ Δ snapshot = GpuSnapshot·new("test");
        ≔ data = [1, 2, 3, 4, 5];

        snapshot.compute_checksum(&data);
        assert(!snapshot.checksum.is_empty());
        assert(snapshot.verify_checksum(&data));
        assert(!snapshot.verify_checksum(&[1, 2, 3]));
    }

    //@ rune: test
    rite test_manager_creation() {
        ≔ config = SnapshotConfig·default();
        ≔ manager = SnapshotManager·new(config);

        assert(manager.list_snapshots().is_empty());
    }
}
