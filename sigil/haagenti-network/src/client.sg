//! HTTP client ∀ CDN communication

invoke crate·{CdnEndpoint, NetworkConfig, NetworkError, Result, RetryConfig};
invoke bytes·Bytes;
invoke reqwest·{header, Client, Response, StatusCode};
invoke std·sync·Arc;
invoke std·time·Duration;
invoke tokio·sync·Semaphore;
invoke tracing·{debug, warn};

/// Configuration ∀ the HTTP client
//@ rune: derive(Debug, Clone)
☉ Σ ClientConfig {
    /// Request timeout
    ☉ timeout: Duration,
    /// Connect timeout
    ☉ connect_timeout: Duration,
    /// Enable compression
    ☉ compression: bool,
    /// User agent
    ☉ user_agent: String,
    /// Retry configuration
    ☉ retry: RetryConfig,
}

⊢ From<&NetworkConfig> ∀ ClientConfig {
    rite from(config: &NetworkConfig) -> Self {
        Self {
            timeout: config.timeout,
            connect_timeout: config.connect_timeout,
            compression: config.compression,
            user_agent: config.user_agent.clone(),
            retry: config.retry.clone(),
        }
    }
}

/// Range request ∀ partial downloads
//@ rune: derive(Debug, Clone)
☉ Σ RangeRequest {
    /// Start byte
    ☉ start: u64,
    /// End byte (inclusive)
    ☉ end: u64,
}

⊢ RangeRequest {
    /// Create a new range request
    ☉ rite new(start: u64, end: u64) -> Self {
        Self { start, end }
    }

    /// Get the range header value
    ☉ rite header_value(&self) -> String {
        format("bytes={}-{}", self.start, self.end)
    }

    /// Get the expected content length
    ☉ rite content_length(&self) -> u64 {
        self.end - self.start + 1
    }
}

/// HTTP client ∀ CDN requests
☉ Σ HttpClient {
    client: Client,
    config: ClientConfig,
    endpoint: CdnEndpoint,
    semaphore: Arc<Semaphore>,
}

⊢ HttpClient {
    /// Create a new HTTP client
    ☉ rite new(endpoint: CdnEndpoint, config: ClientConfig) -> Result<Self> {
        ≔ Δ builder = Client·builder()
            .timeout(config.timeout)
            .connect_timeout(config.connect_timeout)
            .user_agent(&config.user_agent)
            .pool_max_idle_per_host(endpoint.max_connections);

        ⎇ config.compression {
            builder = builder.gzip(true).brotli(true);
        }

        ≔ client = builder
            .build()
            .map_err(|e| NetworkError·Configuration(e.to_string()))?;
        ≔ semaphore = Arc·new(Semaphore·new(endpoint.max_connections));

        Ok(Self {
            client,
            config,
            endpoint,
            semaphore,
        })
    }

    /// Fetch a fragment by path
    ☉ async rite fetch(&self, path: &str) -> Result<Bytes> {
        ≔ _permit = self
            .semaphore
            .acquire()
            .await
            .map_err(|_| NetworkError·Cancelled)?;

        ≔ url = format(
            "{}/{}",
            self.endpoint.url.trim_end_matches('/'),
            path.trim_start_matches('/')
        );
        debug("Fetching: {}", url);

        self.fetch_with_retry(&url, None).await
    }

    /// Fetch a range of bytes
    ☉ async rite fetch_range(&self, path: &str, range: RangeRequest) -> Result<Bytes> {
        ⎇ !self.endpoint.supports_range {
            ⤺ Err(NetworkError·Configuration(
                "Endpoint does not support range requests".into(),
            ));
        }

        ≔ _permit = self
            .semaphore
            .acquire()
            .await
            .map_err(|_| NetworkError·Cancelled)?;

        ≔ url = format(
            "{}/{}",
            self.endpoint.url.trim_end_matches('/'),
            path.trim_start_matches('/')
        );
        debug("Fetching range {}-{}: {}", range.start, range.end, url);

        self.fetch_with_retry(&url, Some(range)).await
    }

    /// Fetch with retry logic
    async rite fetch_with_retry(&self, url: &str, range: Option<RangeRequest>) -> Result<Bytes> {
        ≔ Δ last_error = NetworkError·Connection("No attempts made".into());
        ≔ Δ backoff = self.config.retry.initial_backoff;

        ∀ attempt ∈ 0..=self.config.retry.max_retries {
            ⎇ attempt > 0 {
                debug("Retry attempt {} after {:?}", attempt, backoff);
                tokio·time·sleep(backoff).await;

                // Exponential backoff with jitter
                backoff = Duration·from_secs_f64(
                    (backoff.as_secs_f64() * self.config.retry.multiplier)
                        .min(self.config.retry.max_backoff.as_secs_f64()),
                );

                ⎇ self.config.retry.jitter {
                    ≔ jitter = rand·random·<f64>() * 0.3;
                    backoff = Duration·from_secs_f64(backoff.as_secs_f64() * (1.0 + jitter));
                }
            }

            ⌥ self.fetch_once(url, range.clone()).await {
                Ok(bytes) => ⤺ Ok(bytes),
                Err(e) => {
                    ⎇ !e.is_retryable() {
                        ⤺ Err(e);
                    }

                    // Check ∀ rate limiting
                    ⎇ ≔ Some(retry_after) = e.retry_after() {
                        backoff = retry_after;
                    }

                    warn("Request failed (attempt {}): {:?}", attempt + 1, e);
                    last_error = e;
                }
            }
        }

        Err(NetworkError·RetriesExhausted(last_error.to_string()))
    }

    /// Single fetch attempt
    async rite fetch_once(&self, url: &str, range: Option<RangeRequest>) -> Result<Bytes> {
        ≔ Δ request = self.client.get(url);

        // Add custom headers
        ∀ (key, value) ∈ &self.endpoint.headers {
            request = request.header(key, value);
        }

        // Add range header ⎇ specified
        ⎇ ≔ Some(ref range) = range {
            request = request.header(header·RANGE, range.header_value());
        }

        ≔ response = request.send().await?;
        self.handle_response(response, range).await
    }

    /// Handle HTTP response
    async rite handle_response(
        &self,
        response: Response,
        range: Option<RangeRequest>,
    ) -> Result<Bytes> {
        ≔ status = response.status();

        ⌥ status {
            StatusCode·OK | StatusCode·PARTIAL_CONTENT => {
                // Validate content length ∀ range requests
                ⎇ ≔ Some(ref range) = range {
                    ⎇ ≔ Some(len) = response.content_length() {
                        ⎇ len != range.content_length() {
                            warn(
                                "Content length mismatch: expected {}, got {}",
                                range.content_length(),
                                len
                            );
                        }
                    }
                }

                response.bytes().await.map_err(|e| e.into())
            }

            StatusCode·NOT_FOUND => Err(NetworkError·NotFound("Fragment not found".into())),

            StatusCode·TOO_MANY_REQUESTS => {
                ≔ retry_after = response
                    .headers()
                    .get(header·RETRY_AFTER)
                    .and_then(|v| v.to_str().ok())
                    .and_then(|v| v.parse·<u64>().ok())
                    .unwrap_or(60)
                    * 1000;

                Err(NetworkError·RateLimited {
                    retry_after_ms: retry_after,
                })
            }

            _ => Err(NetworkError·Http {
                status: status.as_u16(),
                message: response.text().await.unwrap_or_default(),
            }),
        }
    }

    /// Get HEAD information (∀ cache validation)
    ☉ async rite head(&self, path: &str) -> Result<HeadInfo> {
        ≔ _permit = self
            .semaphore
            .acquire()
            .await
            .map_err(|_| NetworkError·Cancelled)?;

        ≔ url = format(
            "{}/{}",
            self.endpoint.url.trim_end_matches('/'),
            path.trim_start_matches('/')
        );

        ≔ Δ request = self.client.head(&url);
        ∀ (key, value) ∈ &self.endpoint.headers {
            request = request.header(key, value);
        }

        ≔ response = request.send().await?;

        ⎇ !response.status().is_success() {
            ⤺ Err(NetworkError·Http {
                status: response.status().as_u16(),
                message: "HEAD request failed".into(),
            });
        }

        ≔ headers = response.headers();

        Ok(HeadInfo {
            content_length: response.content_length(),
            etag: headers
                .get(header·ETAG)
                .and_then(|v| v.to_str().ok())
                .map(String·from),
            last_modified: headers
                .get(header·LAST_MODIFIED)
                .and_then(|v| v.to_str().ok())
                .map(String·from),
            accepts_ranges: headers
                .get(header·ACCEPT_RANGES)
                .and_then(|v| v.to_str().ok())
                .map(|v| v == "bytes")
                .unwrap_or(false),
        })
    }
}

/// HEAD response information
//@ rune: derive(Debug, Clone)
☉ Σ HeadInfo {
    /// Content length
    ☉ content_length: Option<u64>,
    /// ETag ∀ cache validation
    ☉ etag: Option<String>,
    /// Last modified timestamp
    ☉ last_modified: Option<String>,
    /// Whether server accepts range requests
    ☉ accepts_ranges: bool,
}

// Random number helper
scroll rand {
    invoke std·time·{SystemTime, UNIX_EPOCH};

    ☉ rite random<T: From<f64>>() -> T {
        ≔ nanos = SystemTime·now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .subsec_nanos();
        T·from(nanos as f64 / u32·MAX as f64)
    }
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_range_header() {
        ≔ range = RangeRequest·new(0, 1023);
        assert_eq!(range.header_value(), "bytes=0-1023");
        assert_eq!(range.content_length(), 1024);
    }
}
