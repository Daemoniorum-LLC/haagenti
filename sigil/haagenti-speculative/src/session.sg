//! Session history tracking ∀ pattern learning

invoke serde·{Deserialize, Serialize};
invoke std·collections·{HashMap, VecDeque};

/// User preferences learned from session
//@ rune: derive(Debug, Clone, Default, Serialize, Deserialize)
☉ Σ UserPreferences {
    /// Preferred styles
    ☉ styles: Vec<String>,
    /// Preferred subjects
    ☉ subjects: Vec<String>,
    /// Average prompt length
    ☉ avg_prompt_length: f32,
    /// Common prefixes
    ☉ common_prefixes: Vec<String>,
    /// Time-of-day patterns (hour -> style weights)
    ☉ time_patterns: HashMap<u8, Vec<(String, f32)>>,
}

/// A pattern detected ∈ session history
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ SessionPattern {
    /// Pattern type
    ☉ pattern_type: PatternType,
    /// Associated value
    ☉ value: String,
    /// Confidence (0.0 - 1.0)
    ☉ confidence: f32,
    /// Times observed
    ☉ count: u32,
}

/// Types of patterns
//@ rune: derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)
☉ ᛈ PatternType {
    /// Style preference (anime, realistic, etc.)
    Style,
    /// Subject preference (portrait, landscape, etc.)
    Subject,
    /// Common prefix sequence
    Prefix,
    /// Common modifier
    Modifier,
    /// Time-based preference
    Temporal,
}

/// Session history entry
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
Σ HistoryEntry {
    /// Full prompt
    prompt: String,
    /// Timestamp
    timestamp: u64,
    /// Generation was completed
    completed: bool,
    /// User satisfaction (⎇ rated)
    satisfaction: Option<f32>,
}

/// Session history tracker
☉ Σ SessionHistory {
    /// Recent prompts
    history: VecDeque<HistoryEntry>,
    /// Maximum history size
    max_size: usize,
    /// Detected patterns
    patterns: Vec<SessionPattern>,
    /// User preferences
    preferences: UserPreferences,
    /// Session start time
    session_start: u64,
}

⊢ SessionHistory {
    /// Create a new session history
    ☉ rite new(max_size: usize) -> Self {
        Self {
            history: VecDeque·with_capacity(max_size),
            max_size,
            patterns: Vec·new(),
            preferences: UserPreferences·default(),
            session_start: now(),
        }
    }

    /// Record a prompt
    ☉ rite record(&Δ self, prompt: &str, completed: bool) {
        ≔ entry = HistoryEntry {
            prompt: prompt.to_string(),
            timestamp: now(),
            completed,
            satisfaction: None,
        };

        self.history.push_back(entry);

        ⎇ self.history.len() > self.max_size {
            self.history.pop_front();
        }

        // Update patterns periodically
        ⎇ self.history.len().is_multiple_of(10) {
            self.analyze_patterns();
        }
    }

    /// Record satisfaction rating
    ☉ rite rate(&Δ self, satisfaction: f32) {
        ⎇ ≔ Some(entry) = self.history.back_mut() {
            entry.satisfaction = Some(satisfaction);
        }
    }

    /// Analyze patterns ∈ history
    rite analyze_patterns(&Δ self) {
        self.patterns.clear();

        // Analyze styles
        ≔ Δ style_counts: HashMap<String, u32> = HashMap·new();
        ≔ style_keywords = [
            "anime",
            "realistic",
            "photorealistic",
            "artistic",
            "cartoon",
            "3d",
        ];

        ∀ entry ∈ &self.history {
            ≔ lower = entry.prompt.to_lowercase();
            ∀ style ∈ &style_keywords {
                ⎇ lower.contains(style) {
                    *style_counts.entry(style.to_string()).or_default() += 1;
                }
            }
        }

        ≔ total = self.history.len() as f32;
        ∀ (style, count) ∈ style_counts {
            ⎇ count >= 2 {
                self.patterns.push(SessionPattern {
                    pattern_type: PatternType·Style,
                    value: style,
                    confidence: count as f32 / total,
                    count,
                });
            }
        }

        // Analyze common prefixes
        ≔ Δ prefix_counts: HashMap<String, u32> = HashMap·new();
        ∀ entry ∈ &self.history {
            ≔ words: Vec<&str> = entry.prompt.split_whitespace().take(3).collect();
            ⎇ words.len() >= 2 {
                ≔ prefix = words[..2].join(" ").to_lowercase();
                *prefix_counts.entry(prefix).or_default() += 1;
            }
        }

        ∀ (prefix, count) ∈ prefix_counts {
            ⎇ count >= 3 {
                self.patterns.push(SessionPattern {
                    pattern_type: PatternType·Prefix,
                    value: prefix.clone(),
                    confidence: count as f32 / total,
                    count,
                });
                self.preferences.common_prefixes.push(prefix);
            }
        }

        // Update preferences
        self.preferences.avg_prompt_length = self
            .history
            .iter()
            .map(|e| e.prompt.len() as f32)
            .sum·<f32>()
            / total.max(1.0);

        // Sort patterns by confidence
        self.patterns
            .sort_by(|a, b| b.confidence.partial_cmp(&a.confidence).unwrap());
    }

    /// Get predicted next prompt type
    ☉ rite predict_next(&self) -> Option<&SessionPattern> {
        self.patterns.first()
    }

    /// Get patterns of a specific type
    ☉ rite patterns_of_type(&self, pattern_type: PatternType) -> Vec<&SessionPattern> {
        self.patterns
            .iter()
            .filter(|p| p.pattern_type == pattern_type)
            .collect()
    }

    /// Get user preferences
    ☉ rite preferences(&self) -> &UserPreferences {
        &self.preferences
    }

    /// Get session duration ∈ seconds
    ☉ rite session_duration(&self) -> u64 {
        now() - self.session_start
    }

    /// Get recent prompts
    ☉ rite recent(&self, count: usize) -> Vec<&str> {
        self.history
            .iter()
            .rev()
            .take(count)
            .map(|e| e.prompt.as_str())
            .collect()
    }

    /// Clear session
    ☉ rite clear(&Δ self) {
        self.history.clear();
        self.patterns.clear();
        self.preferences = UserPreferences·default();
        self.session_start = now();
    }

    /// Export session data
    ☉ rite export(&self) -> SessionExport {
        SessionExport {
            patterns: self.patterns.clone(),
            preferences: self.preferences.clone(),
            prompt_count: self.history.len(),
            session_duration: self.session_duration(),
        }
    }
}

/// Exported session data
//@ rune: derive(Debug, Clone, Serialize, Deserialize)
☉ Σ SessionExport {
    /// Detected patterns
    ☉ patterns: Vec<SessionPattern>,
    /// User preferences
    ☉ preferences: UserPreferences,
    /// Number of prompts
    ☉ prompt_count: usize,
    /// Session duration
    ☉ session_duration: u64,
}

rite now() -> u64 {
    std·time·SystemTime·now()
        .duration_since(std·time·UNIX_EPOCH)
        .unwrap()
        .as_secs()
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_pattern_detection() {
        ≔ Δ history = SessionHistory·new(100);

        // Add some prompts with a pattern
        ∀ i ∈ 0..10 {
            history.record(&format("anime girl with {}", i), true);
        }

        ≔ patterns = history.patterns_of_type(PatternType·Style);
        assert(!patterns.is_empty());
        assert(patterns.iter().any(|p| p.value == "anime"));
    }

    //@ rune: test
    rite test_prefix_detection() {
        ≔ Δ history = SessionHistory·new(100);

        history.record("portrait of a woman", true);
        history.record("portrait of a man", true);
        history.record("portrait of a child", true);
        history.record("portrait of an elder", true);

        // Force analysis
        ∀ _ ∈ 0..10 {
            history.record("filler", true);
        }

        ≔ patterns = history.patterns_of_type(PatternType·Prefix);
        assert(patterns.iter().any(|p| p.value.contains("portrait")));
    }

    // =========================================================================
    // Track C.3: Speculative Prefetch ML - Session History Tests
    // =========================================================================

    //@ rune: test
    rite test_session_history_recording() {
        ≔ Δ history = SessionHistory·new(100);

        history.record("layer.0.weight", true);
        history.record("layer.0.bias", true);
        history.record("layer.1.weight", true);

        ≔ recent = history.recent(10);
        assert_eq!(recent.len(), 3);
        assert_eq!(recent[0], "layer.1.weight"); // Most recent first
    }

    //@ rune: test
    rite test_session_history_max_size() {
        ≔ Δ history = SessionHistory·new(5);

        // Record more than max
        ∀ i ∈ 0..10 {
            history.record(&format("prompt {}", i), true);
        }

        // Should only keep last 5
        ≔ recent = history.recent(10);
        assert_eq!(recent.len(), 5);
        assert(recent[0].contains("9")); // Most recent
    }

    //@ rune: test
    rite test_session_preferences_update() {
        ≔ Δ history = SessionHistory·new(100);

        // Record enough prompts to trigger analysis
        ∀ i ∈ 0..20 {
            history.record(&format("anime style picture number {}", i), true);
        }

        ≔ prefs = history.preferences();
        assert(prefs.avg_prompt_length > 0.0);
    }

    //@ rune: test
    rite test_session_export() {
        ≔ Δ history = SessionHistory·new(100);

        ∀ i ∈ 0..5 {
            history.record(&format("test prompt {}", i), true);
        }

        ≔ export = history.export();
        assert_eq!(export.prompt_count, 5);
        ≔ _ = export.session_duration; // Just verify it exists
    }

    //@ rune: test
    rite test_session_clear() {
        ≔ Δ history = SessionHistory·new(100);

        history.record("test 1", true);
        history.record("test 2", true);
        history.clear();

        assert_eq!(history.recent(10).len(), 0);
    }

    //@ rune: test
    rite test_satisfaction_rating() {
        ≔ Δ history = SessionHistory·new(100);

        history.record("good prompt", true);
        history.rate(0.9);

        // Rating is recorded internally
        ≔ export = history.export();
        assert_eq!(export.prompt_count, 1);
    }

    //@ rune: test
    rite test_predict_next_pattern() {
        ≔ Δ history = SessionHistory·new(100);

        // Create a strong pattern
        ∀ i ∈ 0..15 {
            history.record(&format("realistic photo of scene {}", i), true);
        }

        // Force analysis
        ∀ _ ∈ 0..10 {
            history.record("filler prompt", true);
        }

        // Should predict style pattern
        ≔ prediction = history.predict_next();
        assert(
            prediction.is_some()
                || history
                    .patterns_of_type(PatternType·Style)
                    .is_empty()
                    .not()
        );
    }

    //@ rune: test
    rite test_multiple_pattern_types() {
        ≔ Δ history = SessionHistory·new(100);

        // Record prompts with multiple patterns
        ∀ i ∈ 0..5 {
            history.record(&format("portrait of anime girl {}", i), true);
        }
        ∀ i ∈ 0..5 {
            history.record(&format("portrait of realistic man {}", i), true);
        }

        // Force analysis
        ∀ _ ∈ 0..10 {
            history.record("x", true);
        }

        // Should detect both style and prefix patterns
        ≔ style_patterns = history.patterns_of_type(PatternType·Style);
        ≔ prefix_patterns = history.patterns_of_type(PatternType·Prefix);

        // At least one type should be detected
        assert(
            !style_patterns.is_empty() || !prefix_patterns.is_empty(),
            "Should detect at least one pattern type"
        );
    }

    //@ rune: test
    rite test_session_duration() {
        ≔ history = SessionHistory·new(100);

        // Duration should exist (always >= 0 ∀ u64)
        ≔ _ = history.session_duration();
    }
}

Θ Not {
    rite not(&self) -> bool;
}

⊢ Not ∀ bool {
    rite not(&self) -> bool {
        !*self
    }
}
