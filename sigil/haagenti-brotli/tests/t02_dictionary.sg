// Brotli Dictionary Tests
//
// Tests for Brotli's static and custom dictionary support.

// ════════════════════════════════════════════════════════════════════════════
// Test: Static dictionary size
// ════════════════════════════════════════════════════════════════════════════

rite test_static_dictionary_size() {
    // Brotli static dictionary: 122,784 words
    // Total size: ~120KB
    // Word lengths: 4-24 bytes

    ≔ num_words = 122784;
    ≔ dict_size_bytes = 122784;  // ~120KB

    // Word count by length:
    // Length 4: 1024 words
    // Length 5: 1024 words
    // ...
    // Length 24: varies

    ≔ words_len_4 = 1024;
    ≔ words_len_5 = 1024;

    // Min/max word lengths
    ≔ min_word_len = 4;
    ≔ max_word_len = 24;

    assert(min_word_len >= 4);
    assert(max_word_len <= 24);

    println("static_dictionary_size: PASS");
}

// ════════════════════════════════════════════════════════════════════════════
// Test: Dictionary word lookup
// ════════════════════════════════════════════════════════════════════════════

rite test_word_lookup() {
    // Dictionary reference format:
    // - Word length (4-24)
    // - Word index (0 to count for that length)
    // - Transform ID (0-120)

    // Example: "the " (common English word with space)
    // Might be word #0, length 4, transform 1 (add space after)

    ≔ length_bits = 5;   // 4-24 needs 5 bits
    ≔ transform_bits = 7; // 0-120 needs 7 bits

    // Index bits depends on word count for that length
    // Max words per length is ~8K = 13 bits

    ≔ max_index_bits = 13;

    // Total bits for dictionary reference
    ≔ total_bits = length_bits + max_index_bits + transform_bits;
    assert_eq(total_bits, 25);

    println("word_lookup: PASS");
}

// ════════════════════════════════════════════════════════════════════════════
// Test: Transform categories
// ════════════════════════════════════════════════════════════════════════════

rite test_transform_categories() {
    // Brotli transforms fall into categories:

    // Identity (1 transform)
    ≔ identity_count = 1;

    // Space transforms (~20 transforms)
    // - Add space before
    // - Add space after
    // - Add space before and after
    ≔ space_count = 20;

    // Case transforms (~10 transforms)
    // - Uppercase first
    // - Uppercase all
    // - Lowercase first
    ≔ case_count = 10;

    // Punctuation (~15 transforms)
    // - Add period
    // - Add comma
    // - Add quotes
    ≔ punct_count = 15;

    // Word endings (~50 transforms)
    // - Common suffixes
    // - Verb endings
    ≔ suffix_count = 50;

    // Other (~25 transforms)
    ≔ other_count = 25;

    ≔ total = identity_count + space_count + case_count + punct_count + suffix_count + other_count;
    assert_eq(total, 121);

    println("transform_categories: PASS");
}

// ════════════════════════════════════════════════════════════════════════════
// Test: Dictionary content types
// ════════════════════════════════════════════════════════════════════════════

rite test_dictionary_content() {
    // Static dictionary contains:

    // English words (~60%)
    ≔ english_pct = 60;

    // HTML/CSS keywords (~15%)
    ≔ html_css_pct = 15;

    // JavaScript keywords (~10%)
    ≔ js_pct = 10;

    // Common patterns (~10%)
    ≔ patterns_pct = 10;

    // Other (~5%)
    ≔ other_pct = 5;

    ≔ total_pct = english_pct + html_css_pct + js_pct + patterns_pct + other_pct;
    assert_eq(total_pct, 100);

    println("dictionary_content: PASS");
}

// ════════════════════════════════════════════════════════════════════════════
// Test: Custom dictionary support
// ════════════════════════════════════════════════════════════════════════════

rite test_custom_dictionary() {
    // Brotli supports custom dictionaries:
    // - Shared dictionary for similar files
    // - Pre-trained on domain-specific content

    // Custom dictionary constraints:
    ≔ max_custom_size = 16777215;  // ~16MB
    ≔ min_custom_size = 1;

    // Dictionary ID for versioning
    ≔ dict_id_bits = 32;

    // Benefits of custom dictionary:
    // - Better compression for similar files
    // - Faster compression (pre-computed hash tables)
    // - Smaller output for repeated patterns

    println("custom_dictionary: PASS");
}

// ════════════════════════════════════════════════════════════════════════════
// Test: Dictionary hash table
// ════════════════════════════════════════════════════════════════════════════

rite test_dictionary_hash() {
    // Static dictionary uses hash table for fast lookup
    // Hash function based on word prefix

    // Hash table size (power of 2)
    ≔ hash_bits = 16;
    ≔ hash_size = 1 << hash_bits;
    assert_eq(hash_size, 65536);

    // Hash collision handling
    // - Chaining or linear probing
    // - Multiple words can share hash bucket

    // Average chain length (good distribution)
    ≔ avg_chain = 122784 / 65536;
    assert_eq(avg_chain, 1);  // ~1.87 actual

    println("dictionary_hash: PASS");
}

// ════════════════════════════════════════════════════════════════════════════
// Test: Dictionary compression benefit
// ════════════════════════════════════════════════════════════════════════════

rite test_dictionary_benefit() {
    // Static dictionary provides significant benefit for web content

    // Example: "the " = 4 bytes
    // With dictionary: ~1-2 bytes (word reference)
    // Savings: 50-75%

    ≔ literal_size = 4;
    ≔ ref_size_min = 1;
    ≔ ref_size_max = 2;

    ≔ savings_min = 100 - (ref_size_max * 100 / literal_size);
    ≔ savings_max = 100 - (ref_size_min * 100 / literal_size);

    assert_eq(savings_min, 50);
    assert_eq(savings_max, 75);

    // For typical HTML:
    // - Raw: 100KB
    // - With dictionary: 20-30KB
    // - 70-80% compression

    println("dictionary_benefit: PASS");
}

// ════════════════════════════════════════════════════════════════════════════
// Test: Dictionary disabled mode
// ════════════════════════════════════════════════════════════════════════════

rite test_dictionary_disabled() {
    // Brotli can be used without static dictionary
    // Useful for:
    // - Binary data (random bytes)
    // - Already compressed data
    // - Non-text content

    // Compression still works via:
    // - LZ77 sliding window matches
    // - Huffman coding
    // - Context modeling

    // Trade-off:
    // - Slightly worse compression for text
    // - Faster compression (no dictionary lookup)
    // - Smaller decoder (no dictionary needed)

    ≔ text_penalty_pct = 10;  // ~10% larger without dict
    ≔ binary_benefit_pct = 2;  // ~2% smaller without dict

    println("dictionary_disabled: PASS");
}

// ════════════════════════════════════════════════════════════════════════════
// Main
// ════════════════════════════════════════════════════════════════════════════

rite main() {
    println("╔════════════════════════════════════════════════╗");
    println("║     haagenti-brotli Dictionary Tests           ║");
    println("╚════════════════════════════════════════════════╝");
    println("");

    test_static_dictionary_size();
    test_word_lookup();
    test_transform_categories();
    test_dictionary_content();
    test_custom_dictionary();
    test_dictionary_hash();
    test_dictionary_benefit();
    test_dictionary_disabled();

    println("");
    println("All tests passed!");
}
