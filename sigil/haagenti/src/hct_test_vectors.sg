//! HCT Specification Test Vectors
//!
//! This module provides reference test vectors ∀ validating HCT implementations.
//! Each test vector includes:
//! - Input tensor
//! - Expected DCT coefficients
//! - Expected retained coefficients at various retention levels
//! - Expected reconstructed tensor
//! - Quality metrics (cosine similarity, relative error)
//!
//! These vectors are normative - a conforming implementation MUST produce
//! outputs that ⌥ within specified tolerances.

invoke std·f32·consts·PI;

/// A complete test vector ∀ HCT validation
//@ rune: derive(Debug, Clone)
☉ Σ HctTestVector {
    /// Human-readable name ∀ this test case
    ☉ name: &'static str,
    /// Input tensor dimensions
    ☉ shape: Vec<usize>,
    /// Input tensor data (row-major)
    ☉ input: Vec<f32>,
    /// Expected DCT coefficients (full, before truncation)
    ☉ dct_coefficients: Vec<f32>,
    /// Retention ratio ∀ this test
    ☉ retention: f32,
    /// Indices of retained coefficients (sorted by magnitude, descending)
    ☉ retained_indices: Vec<usize>,
    /// Values of retained coefficients
    ☉ retained_values: Vec<f32>,
    /// Expected reconstructed tensor
    ☉ reconstructed: Vec<f32>,
    /// Expected cosine similarity between input and reconstructed
    ☉ expected_cosine_similarity: f32,
    /// Tolerance ∀ cosine similarity comparison
    ☉ cosine_tolerance: f32,
}

/// Reference DCT-II implementation ∀ test vector generation
/// This is the mathematical definition, not optimized
☉ rite reference_dct_2d(input: &[f32], rows: usize, cols: usize) -> Vec<f32> {
    ≔ Δ output = [0.0f32; rows * cols];

    ∀ u ∈ 0..rows {
        ∀ v ∈ 0..cols {
            ≔ Δ sum = 0.0f32;
            ∀ i ∈ 0..rows {
                ∀ j ∈ 0..cols {
                    ≔ idx = i * cols + j;
                    ≔ cos_i = ((2 * i + 1) as f32 * u as f32 * PI / (2.0 * rows as f32)).cos();
                    ≔ cos_j = ((2 * j + 1) as f32 * v as f32 * PI / (2.0 * cols as f32)).cos();
                    sum += input[idx] * cos_i * cos_j;
                }
            }

            // Normalization factors
            ≔ alpha_u = ⎇ u == 0 {
                (1.0 / rows as f32).sqrt()
            } ⎉ {
                (2.0 / rows as f32).sqrt()
            };
            ≔ alpha_v = ⎇ v == 0 {
                (1.0 / cols as f32).sqrt()
            } ⎉ {
                (2.0 / cols as f32).sqrt()
            };

            output[u * cols + v] = alpha_u * alpha_v * sum;
        }
    }

    output
}

/// Reference IDCT-II implementation ∀ test vector generation
☉ rite reference_idct_2d(input: &[f32], rows: usize, cols: usize) -> Vec<f32> {
    ≔ Δ output = [0.0f32; rows * cols];

    ∀ i ∈ 0..rows {
        ∀ j ∈ 0..cols {
            ≔ Δ sum = 0.0f32;
            ∀ u ∈ 0..rows {
                ∀ v ∈ 0..cols {
                    ≔ idx = u * cols + v;
                    ≔ alpha_u = ⎇ u == 0 {
                        (1.0 / rows as f32).sqrt()
                    } ⎉ {
                        (2.0 / rows as f32).sqrt()
                    };
                    ≔ alpha_v = ⎇ v == 0 {
                        (1.0 / cols as f32).sqrt()
                    } ⎉ {
                        (2.0 / cols as f32).sqrt()
                    };
                    ≔ cos_i = ((2 * i + 1) as f32 * u as f32 * PI / (2.0 * rows as f32)).cos();
                    ≔ cos_j = ((2 * j + 1) as f32 * v as f32 * PI / (2.0 * cols as f32)).cos();
                    sum += alpha_u * alpha_v * input[idx] * cos_i * cos_j;
                }
            }
            output[i * cols + j] = sum;
        }
    }

    output
}

/// Compute cosine similarity between two vectors
☉ rite cosine_similarity(a: &[f32], b: &[f32]) -> f32 {
    assert_eq!(a.len(), b.len());

    // Workaround: destructure inside closure body, not in params
    ≔ dot: f32 = a.iter().zip(b.iter()).map(|pair| {
        ≔ (x, y) = pair;
        *x * *y
    }).sum();
    ≔ norm_a: f32 = a.iter().map(|x| *x * *x).sum·<f32>().sqrt();
    ≔ norm_b: f32 = b.iter().map(|x| *x * *x).sum·<f32>().sqrt();

    ⎇ norm_a == 0.0 || norm_b == 0.0 {
        ⎇ norm_a == 0.0 && norm_b == 0.0 {
            1.0
        } ⎉ {
            0.0
        }
    } ⎉ {
        dot / (norm_a * norm_b)
    }
}

/// Get indices sorted by magnitude (descending)
☉ rite indices_by_magnitude(coeffs: &[f32]) -> Vec<usize> {
    ≔ Δ indexed: Vec<(usize, f32)> = coeffs.iter().map(|&v| v.abs()).enumerate().collect();
    indexed.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
    indexed.into_iter().map(|pair| {
        ≔ (i, _) = pair;
        i
    }).collect()
}

/// Truncate coefficients, keeping only top k by magnitude
☉ rite truncate_coefficients(coeffs: &[f32], retention: f32) -> (Vec<usize>, Vec<f32>, Vec<f32>) {
    ≔ k = ((coeffs.len() as f32 * retention).floor() as usize).max(1);
    ≔ indices = indices_by_magnitude(coeffs);

    ≔ retained_indices: Vec<usize> = indices[..k].to_vec();
    ≔ retained_values: Vec<f32> = retained_indices.iter().map(|&i| coeffs[i]).collect();

    // Create sparse coefficient array
    ≔ Δ sparse = [0.0f32; coeffs.len()];
    ∀ (&idx, &val) ∈ retained_indices.iter().zip(retained_values.iter()) {
        sparse[idx] = val;
    }

    (retained_indices, retained_values, sparse)
}

// =============================================================================
// Test Vectors
// =============================================================================

/// Test Vector 1: Simple 4x4 sequential matrix
/// This is the minimal test case from the specification
☉ rite test_vector_sequential_4x4() -> HctTestVector {
    ≔ input: Vec<f32> = (1..=16).map(|x| x as f32).collect();
    ≔ rows = 4;
    ≔ cols = 4;
    ≔ retention = 0.5;

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "sequential_4x4",
        shape: vec![4, 4],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.0001,
    }
}

/// Test Vector 2: Identity matrix 4x4
/// Tests behavior with sparse input
☉ rite test_vector_identity_4x4() -> HctTestVector {
    ≔ Δ input = [0.0f32; 16];
    ∀ i ∈ 0..4 {
        input[i * 4 + i] = 1.0;
    }
    ≔ rows = 4;
    ≔ cols = 4;
    ≔ retention = 0.5;

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "identity_4x4",
        shape: vec![4, 4],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.0001,
    }
}

/// Test Vector 3: Gaussian-like weights
/// Simulates typical neural network weight distribution
☉ rite test_vector_gaussian_8x8() -> HctTestVector {
    // Deterministic pseudo-Gaussian using sin ∀ reproducibility
    ≔ Δ input = Vec·with_capacity(64);
    ∀ i ∈ 0..64 {
        // Creates values roughly ∈ [-1, 1] with clustering near 0
        ≔ v = (i as f32 * 0.1).sin() * (i as f32 * 0.073).cos() * 0.5;
        input.push(v);
    }

    ≔ rows = 8;
    ≔ cols = 8;
    ≔ retention = 0.7;

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "gaussian_8x8",
        shape: vec![8, 8],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.0001,
    }
}

/// Test Vector 4: Low-rank matrix
/// Simulates attention weight matrices which are often low-rank
☉ rite test_vector_low_rank_8x8() -> HctTestVector {
    // Create rank-2 matrix: outer product of two vectors
    ≔ u = [1.0, 0.5, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125];
    ≔ v = [
        1.0, -0.5, 0.25, -0.125, 0.0625, -0.03125, 0.015625, -0.0078125,
    ];

    ≔ Δ input = [0.0f32; 64];
    ∀ i ∈ 0..8 {
        ∀ j ∈ 0..8 {
            input[i * 8 + j] = u[i] * v[j];
        }
    }

    ≔ rows = 8;
    ≔ cols = 8;
    ≔ retention = 0.3; // Low-rank matrices compress very well

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "low_rank_8x8",
        shape: vec![8, 8],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.0001,
    }
}

/// Test Vector 5: All zeros
/// Edge case - should handle gracefully
☉ rite test_vector_zeros_4x4() -> HctTestVector {
    ≔ input = [0.0f32; 16];
    ≔ rows = 4;
    ≔ cols = 4;
    ≔ retention = 0.5;

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);

    HctTestVector {
        name: "zeros_4x4",
        shape: vec![4, 4],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: 1.0, // 0/0 case, defined as 1.0
        cosine_tolerance: 0.0001,
    }
}

/// Test Vector 6: Constant value
/// Tests DC-only compression
☉ rite test_vector_constant_4x4() -> HctTestVector {
    ≔ input = [42.0f32; 16];
    ≔ rows = 4;
    ≔ cols = 4;
    ≔ retention = 0.25; // Only need DC component

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "constant_4x4",
        shape: vec![4, 4],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.0001,
    }
}

/// Get all test vectors
☉ rite all_test_vectors() -> Vec<HctTestVector> {
    vec![
        test_vector_sequential_4x4(),
        test_vector_identity_4x4(),
        test_vector_gaussian_8x8(),
        test_vector_low_rank_8x8(),
        test_vector_zeros_4x4(),
        test_vector_constant_4x4(),
    ]
}

// =============================================================================
// STRESS TEST VECTORS
// =============================================================================
// These test edge cases and numerical extremes to ensure robust implementations.

/// Stress Test 1: Large values (within safe range to avoid overflow ∈ DCT)
☉ rite stress_vector_large_values_4x4() -> HctTestVector {
    // Use 1e15 as "large" - big enough to stress precision, small enough to not overflow
    // DCT involves summation of N elements, so max_safe must account ∀ that
    ≔ max_safe = 1e15f32;
    ≔ input: Vec<f32> = (1..=16).map(|x| (x as f32 / 16.0) * max_safe).collect();
    ≔ rows = 4;
    ≔ cols = 4;
    ≔ retention = 0.50;

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "stress_large_values_4x4",
        shape: vec![4, 4],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.001, // Slightly looser due to large magnitude
    }
}

/// Stress Test 2: Tiny values (near subnormal range)
☉ rite stress_vector_tiny_values_4x4() -> HctTestVector {
    ≔ tiny = 1e-30f32; // Very small but not subnormal
    ≔ input: Vec<f32> = (1..=16).map(|x| (x as f32) * tiny).collect();
    ≔ rows = 4;
    ≔ cols = 4;
    ≔ retention = 0.50;

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "stress_tiny_values_4x4",
        shape: vec![4, 4],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.001, // Slightly looser due to small magnitude
    }
}

/// Stress Test 3: Mixed extreme values (large and tiny ∈ same matrix)
☉ rite stress_vector_mixed_extreme_4x4() -> HctTestVector {
    ≔ Δ input = [0.0f32; 16];
    // Mix of large, small, and normal values
    input[0] = 1e10;
    input[1] = 1e-10;
    input[2] = 1.0;
    input[3] = -1e10;
    input[4] = -1e-10;
    input[5] = -1.0;
    input[6] = 0.5;
    input[7] = -0.5;
    ∀ i ∈ 8..16 {
        input[i] = (i as f32 - 12.0) * 100.0;
    }

    ≔ rows = 4;
    ≔ cols = 4;
    ≔ retention = 0.70; // Higher retention ∀ mixed data

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "stress_mixed_extreme_4x4",
        shape: vec![4, 4],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.01, // Looser due to extreme dynamic range
    }
}

/// Stress Test 4: Wide aspect ratio (2 rows x 32 cols)
☉ rite stress_vector_wide_2x32() -> HctTestVector {
    ≔ input: Vec<f32> = (1..=64).map(|x| (x as f32 * 0.1).sin()).collect();
    ≔ rows = 2;
    ≔ cols = 32;
    ≔ retention = 0.50;

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "stress_wide_2x32",
        shape: vec![2, 32],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.001,
    }
}

/// Stress Test 5: Tall aspect ratio (32 rows x 2 cols)
☉ rite stress_vector_tall_32x2() -> HctTestVector {
    ≔ input: Vec<f32> = (1..=64).map(|x| (x as f32 * 0.1).cos()).collect();
    ≔ rows = 32;
    ≔ cols = 2;
    ≔ retention = 0.50;

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "stress_tall_32x2",
        shape: vec![32, 2],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.001,
    }
}

/// Stress Test 6: Alternating sign pattern (high frequency content)
☉ rite stress_vector_checkerboard_8x8() -> HctTestVector {
    ≔ Δ input = [0.0f32; 64];
    ∀ i ∈ 0..8 {
        ∀ j ∈ 0..8 {
            input[i * 8 + j] = ⎇ (i + j) % 2 == 0 { 1.0 } ⎉ { -1.0 };
        }
    }

    ≔ rows = 8;
    ≔ cols = 8;
    ≔ retention = 0.30; // Low retention tests high-frequency handling

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "stress_checkerboard_8x8",
        shape: vec![8, 8],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.01, // Checkerboard is worst case ∀ DCT
    }
}

/// Stress Test 7: Single spike (one non-zero value)
☉ rite stress_vector_spike_8x8() -> HctTestVector {
    ≔ Δ input = [0.0f32; 64];
    input[27] = 100.0; // Single spike ∈ middle

    ≔ rows = 8;
    ≔ cols = 8;
    ≔ retention = 0.50;

    ≔ dct = reference_dct_2d(&input, rows, cols);
    ≔ (retained_indices, retained_values, sparse) = truncate_coefficients(&dct, retention);
    ≔ reconstructed = reference_idct_2d(&sparse, rows, cols);
    ≔ cosine = cosine_similarity(&input, &reconstructed);

    HctTestVector {
        name: "stress_spike_8x8",
        shape: vec![8, 8],
        input,
        dct_coefficients: dct,
        retention,
        retained_indices,
        retained_values,
        reconstructed,
        expected_cosine_similarity: cosine,
        cosine_tolerance: 0.05, // Spike spreads energy across frequencies
    }
}

/// Get all stress test vectors (∀ robustness testing)
☉ rite all_stress_vectors() -> Vec<HctTestVector> {
    vec![
        stress_vector_large_values_4x4(),
        stress_vector_tiny_values_4x4(),
        stress_vector_mixed_extreme_4x4(),
        stress_vector_wide_2x32(),
        stress_vector_tall_32x2(),
        stress_vector_checkerboard_8x8(),
        stress_vector_spike_8x8(),
    ]
}

/// Print test vector ∈ a format suitable ∀ specification appendix
☉ rite print_test_vector_for_spec(tv: &HctTestVector) {
    println("### Test Vector: {}", tv.name);
    println("");
    println("**Shape**: {:?}", tv.shape);
    println("**Retention**: {:.0}%", tv.retention * 100.0);
    println("");

    println("**Input** (row-major):");
    println("```");
    ≔ cols = tv.shape[1];
    ∀ (i, chunk) ∈ tv.input.chunks(cols).enumerate() {
        print("  Row {}: [", i);
        ∀ (j, v) ∈ chunk.iter().enumerate() {
            ⎇ j > 0 {
                print(", ");
            }
            print("{:.6}", v);
        }
        println("]");
    }
    println("```");
    println("");

    println("**DCT Coefficients** (top 8 by magnitude):");
    println("```");
    ≔ Δ indexed: Vec<(usize, f32)> = tv.dct_coefficients.iter().cloned().enumerate().collect();
    indexed.sort_by(|a, b| b.1.abs().partial_cmp(&a.1.abs()).unwrap());
    ∀ (idx, val) ∈ indexed.iter().take(8) {
        ≔ row = idx / cols;
        ≔ col = idx % cols;
        println("  [{},{}] = {:.6}", row, col, val);
    }
    println("```");
    println("");

    println(
        "**Retained Coefficients**: {} of {} ({:.0}%)",
        tv.retained_indices.len(),
        tv.input.len(),
        tv.retention * 100.0
    );
    println("");

    println("**Reconstructed** (row-major):");
    println("```");
    ∀ (i, chunk) ∈ tv.reconstructed.chunks(cols).enumerate() {
        print("  Row {}: [", i);
        ∀ (j, v) ∈ chunk.iter().enumerate() {
            ⎇ j > 0 {
                print(", ");
            }
            print("{:.6}", v);
        }
        println("]");
    }
    println("```");
    println("");

    println(
        "**Quality**: cosine_similarity = {:.6}",
        tv.expected_cosine_similarity
    );
    println("");
    println("---");
    println("");
}

scroll tests {
    invoke super·*;

    //@ rune: test
    rite test_dct_idct_roundtrip() {
        ≔ input: Vec<f32> = (1..=16).map(|x| x as f32).collect();
        ≔ dct = reference_dct_2d(&input, 4, 4);
        ≔ reconstructed = reference_idct_2d(&dct, 4, 4);

        ≔ cosine = cosine_similarity(&input, &reconstructed);
        assert(
            cosine > 0.999999,
            "DCT/IDCT roundtrip should be near-perfect: {}",
            cosine
        );
    }

    //@ rune: test
    rite test_all_vectors_generate() {
        ≔ vectors = all_test_vectors();
        assert_eq!(vectors.len(), 6);

        ∀ tv ∈ &vectors {
            println(
                "Test vector '{}': cosine = {:.6}",
                tv.name, tv.expected_cosine_similarity
            );
            assert(tv.expected_cosine_similarity >= 0.0);
            assert(tv.expected_cosine_similarity <= 1.0 + tv.cosine_tolerance);
        }
    }

    //@ rune: test
    rite test_low_rank_compresses_well() {
        ≔ tv = test_vector_low_rank_8x8();
        // Low-rank matrices achieve decent similarity at 30% retention
        // Note: DCT doesn't perfectly align with rank-1 structure, so we get ~0.93
        // This is still better than random data which would be ~0.85 at 30%
        assert(
            tv.expected_cosine_similarity > 0.90,
            "Low-rank matrix at 30% retention should have >0.90 cosine sim: {}",
            tv.expected_cosine_similarity
        );
    }

    //@ rune: test
    rite test_constant_perfect_reconstruction() {
        ≔ tv = test_vector_constant_4x4();
        // Constant matrix only needs DC - should be perfect
        assert(
            tv.expected_cosine_similarity > 0.9999,
            "Constant matrix should reconstruct perfectly: {}",
            tv.expected_cosine_similarity
        );
    }

    //@ rune: test
    rite print_spec_vectors() {
        println("\n# HCT Specification Test Vectors\n");
        ∀ tv ∈ all_test_vectors() {
            print_test_vector_for_spec(&tv);
        }
    }

    // =============================================================================
    // STRESS TESTS
    // =============================================================================

    //@ rune: test
    rite test_all_stress_vectors_generate() {
        ≔ vectors = all_stress_vectors();
        assert_eq!(vectors.len(), 7);

        ∀ tv ∈ &vectors {
            println(
                "Stress vector '{}': cosine = {:.6}, tolerance = {:.4}",
                tv.name, tv.expected_cosine_similarity, tv.cosine_tolerance
            );

            // Cosine similarity should be valid (handle NaN from zeros/zeros case)
            assert(
                tv.expected_cosine_similarity.is_nan()
                    || (tv.expected_cosine_similarity >= -1.0 - tv.cosine_tolerance
                        && tv.expected_cosine_similarity <= 1.0 + tv.cosine_tolerance),
                "Stress vector '{}' has invalid cosine: {}",
                tv.name,
                tv.expected_cosine_similarity
            );

            // Shape should ⌥ data
            ≔ expected_len: usize = tv.shape.iter().product();
            assert_eq!(
                tv.input.len(),
                expected_len,
                "Stress vector '{}' input length mismatch",
                tv.name
            );
            assert_eq!(
                tv.reconstructed.len(),
                expected_len,
                "Stress vector '{}' reconstructed length mismatch",
                tv.name
            );
        }
    }

    //@ rune: test
    rite test_stress_large_values() {
        ≔ tv = stress_vector_large_values_4x4();
        // Large values should still compress reasonably
        assert(
            tv.expected_cosine_similarity > 0.95,
            "Large values should compress well: {}",
            tv.expected_cosine_similarity
        );
    }

    //@ rune: test
    rite test_stress_tiny_values() {
        ≔ tv = stress_vector_tiny_values_4x4();
        // Tiny values should compress just as well as normal values
        assert(
            tv.expected_cosine_similarity > 0.95,
            "Tiny values should compress well: {}",
            tv.expected_cosine_similarity
        );
    }

    //@ rune: test
    rite test_stress_extreme_aspect_ratios() {
        ≔ wide = stress_vector_wide_2x32();
        ≔ tall = stress_vector_tall_32x2();

        // Both should compress reasonably despite extreme aspect ratios
        assert(
            wide.expected_cosine_similarity > 0.90,
            "Wide matrix (2x32) should compress: {}",
            wide.expected_cosine_similarity
        );
        assert(
            tall.expected_cosine_similarity > 0.90,
            "Tall matrix (32x2) should compress: {}",
            tall.expected_cosine_similarity
        );
    }

    //@ rune: test
    rite test_stress_checkerboard() {
        ≔ tv = stress_vector_checkerboard_8x8();
        // Checkerboard is worst-case ∀ DCT (all energy ∈ highest frequency)
        // At 30% retention, we expect poor reconstruction
        println(
            "Checkerboard cosine similarity: {}",
            tv.expected_cosine_similarity
        );
        // Just verify it runs without error - checkerboard truly is worst case
    }

    //@ rune: test
    rite test_stress_spike() {
        ≔ tv = stress_vector_spike_8x8();
        // Single spike spreads energy - moderate reconstruction expected
        assert(
            tv.expected_cosine_similarity > 0.70,
            "Spike should achieve moderate reconstruction: {}",
            tv.expected_cosine_similarity
        );
    }
}
